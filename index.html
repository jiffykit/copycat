<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Match</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="game-container">
        <header class="game-header">
            <h1>üéµ Music Match üéµ</h1>
            <div class="game-info">
                <div class="score">Score: <span id="totalScore">0</span></div>
                <div class="score">Round: <span id="round">1</span></div>
                <div class="score">Lives: <span id="lives">3</span></div>
            </div>
            <div class="controls">
                <button id="startBtn" class="btn primary">üéÆ Start Game</button>
                <button id="stopBtn" class="btn secondary" disabled>üõë Stop</button>
                <button id="resetBtn" class="btn secondary">üîÑ Reset</button>
                <button id="listenAgainBtn" class="btn special" disabled>üëÇ Listen Again</button>
            </div>
            <div class="rhythm-controls">
                <h4>üéµ Rhythm Options:</h4>
                <div class="rhythm-toggles">
                    <label><input type="checkbox" id="rhythmQuarter" checked> ‚ô© - ¬π‚ÅÑ‚ÇÑ notes (üü£ PLUM) </label>
                    <label><input type="checkbox" id="rhythmEighth"> ‚ô´ - ¬π‚ÅÑ‚Çà notes (üçéAPPLE) </label>
                </div>
                <div class="rhythm-toggles" style="margin-top: 10px;">
                    <label><input type="checkbox" id="rhythmTriplet"> ¬≥ - Triplets (üççPINEAPPLE) </label>
                    <label><input type="checkbox" id="rhythmSixteenth"> ‚ô¨ - ¬π‚ÅÑ‚ÇÅ‚ÇÜ notes (üçâWATERMELON) </label>
                </div>
            </div>
            <div class="scale-controls">
                <h4>üéπ Note Options:</h4>
                <div class="scale-options">
                    <label><input type="radio" name="scaleType" value="progressive" checked> üòé Fun Levels</label>
                    <label><input type="radio" name="scaleType" value="custom"> üé® My Own Notes</label>
                    <label><input type="checkbox" id="muteCheeringSound" checked> üîä Sound FX</label>
                </div>
                <div class="custom-scale" id="customScaleContainer" style="display: none;">
                    <div class="note-toggles">
                        <label><input type="checkbox" id="noteC" checked> C</label>
                        <label><input type="checkbox" id="noteCsharp"> C#</label>
                        <label><input type="checkbox" id="noteD"> D</label>
                        <label><input type="checkbox" id="noteDsharp"> D#</label>
                        <label><input type="checkbox" id="noteE" checked> E</label>
                        <label><input type="checkbox" id="noteF"> F</label>
                        <label><input type="checkbox" id="noteFsharp"> F#</label>
                        <label><input type="checkbox" id="noteG" checked> G</label>
                        <label><input type="checkbox" id="noteGsharp"> G#</label>
                        <label><input type="checkbox" id="noteA"> A</label>
                        <label><input type="checkbox" id="noteAsharp"> A#</label>
                        <label><input type="checkbox" id="noteB"> B</label>
                    </div>
                </div>
            </div>
        </header>

        <main class="game-board">
            <div class="clock-container">
                <!-- 12 Colored lights arranged in clock positions -->
                <div class="light" id="light-0" data-position="0" data-note="C" style="--angle: 0deg;">
                    <span class="light-number">C</span>
                </div>
                <div class="light" id="light-1" data-position="1" data-note="C#" style="--angle: 30deg;">
                    <span class="light-number">C#</span>
                </div>
                <div class="light" id="light-2" data-position="2" data-note="D" style="--angle: 60deg;">
                    <span class="light-number">D</span>
                </div>
                <div class="light" id="light-3" data-position="3" data-note="D#" style="--angle: 90deg;">
                    <span class="light-number">D#</span>
                </div>
                <div class="light" id="light-4" data-position="4" data-note="E" style="--angle: 120deg;">
                    <span class="light-number">E</span>
                </div>
                <div class="light" id="light-5" data-position="5" data-note="F" style="--angle: 150deg;">
                    <span class="light-number">F</span>
                </div>
                <div class="light" id="light-6" data-position="6" data-note="F#" style="--angle: 180deg;">
                    <span class="light-number">F#</span>
                </div>
                <div class="light" id="light-7" data-position="7" data-note="G" style="--angle: 210deg;">
                    <span class="light-number">G</span>
                </div>
                <div class="light" id="light-8" data-position="8" data-note="G#" style="--angle: 240deg;">
                    <span class="light-number">G#</span>
                </div>
                <div class="light" id="light-9" data-position="9" data-note="A" style="--angle: 270deg;">
                    <span class="light-number">A</span>
                </div>
                <div class="light" id="light-10" data-position="10" data-note="A#" style="--angle: 300deg;">
                    <span class="light-number">A#</span>
                </div>
                <div class="light" id="light-11" data-position="11" data-note="B" style="--angle: 330deg;">
                    <span class="light-number">B</span>
                </div>
            </div>
        </main>

        <footer class="game-footer">
            <!-- Footer content removed for cleaner interface -->
        </footer>
    </div>

    <script>// Memory Rhythm Game - Main JavaScript File

        class MemoryRhythmGame {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.gameSequence = [];
                this.playerSequence = [];
                this.currentRound = 1;
                this.gameState = 'stopped'; // 'stopped', 'playing', 'listening', 'waiting'
                this.bpm = 50; // Start at 50 BPM, increases by 2 per level, max 85
                this.sequenceTimeout = null;
                this.playerTimeout = null;
                this.isPlayerTurn = false;
                this.currentSequenceIndex = 0; // Track which item in sequence player is on
                this.currentTapCount = 0; // Track taps for current item
                this.tapStartTime = 0; // Track when player started tapping current item
                this.currentItemStartTime = 0; // Track when current sequence item started
                this.currentArrangement = 'chromatic'; // Current clock arrangement
                this.usingCustomScale = false; // Track if using custom scale
                this.customNotes = ['C', 'E', 'G']; // Default custom scale
                this.enabledRhythms = ['quarter']; // Start with only quarters - super simple
                this.currentLevel = 1; // Current level (affects available notes)
                this.correctInRow = 0; // Track consecutive correct answers
                this.lastNoteIndex = -1; // Track last note to avoid repetition
                this.lives = 3; // Start with 3 lives

                // Scoring system
                this.totalScore = 0;
                this.levelScore = 0;
                this.rhythmAccuracy = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.currentLevelRhythmBonus = 0; // Track rhythm bonus for current level only
                this.listenAgainUsed = false; // Track if Listen Again has been used this level

                // Level requirements: sequence length progression (3‚Üí4‚Üí4‚Üí5‚Üí5‚Üí6‚Üí6‚Üí7 etc.)
                this.levelRequirements = {
                    1: 3, // Level 1: 3 notes to complete
                    2: 4, // Level 2: 4 notes to complete
                    3: 4, // Level 3: 4 notes to complete (including A)
                    4: 5, // Level 4: 5 notes to complete
                    5: 5, // Level 5: 5 notes to complete
                    6: 6, // Level 6: 6 notes to complete  
                    7: 6, // Level 7: 6 notes to complete
                    8: 7, // Level 8: 7 notes to complete
                    9: 7, // Level 9: 7 notes to complete
                    10: 8, // Level 10: 8 notes to complete
                    11: 8, // Level 11: 8 notes to complete
                    12: 9, // Level 12: 9 notes to complete
                    13: 9, // Level 13: 9 notes to complete
                    14: 10, // Level 14: 10 notes to complete
                    15: 10, // Level 15: 10 notes to complete
                    16: 11, // Level 16: 11 notes to complete
                    17: 11, // Level 17: 11 notes to complete
                    18: 12, // Level 18: 12 notes to complete (max)
                    19: 12, // Level 19: 12 notes to complete
                    20: 12 // Level 20: 12 notes to complete
                };

                // Progressive note system by level - slower progression
                this.levelNotes = {
                    1: ['C', 'E', 'G'], // Level 1: CEG (3 notes)
                    2: ['C', 'E', 'G'], // Level 2: CEG (3 notes) 
                    3: ['C', 'E', 'G', 'A'], // Level 3: CEGA (4 notes)
                    4: ['C', 'E', 'G', 'A'], // Level 4: CEGA (4 notes)
                    5: ['C', 'E', 'G', 'A', 'D'], // Level 5: CEGAD (5 notes)
                    6: ['C', 'E', 'G', 'A', 'D'], // Level 6: CEGAD (5 notes)
                    7: ['C', 'D', 'E', 'G', 'A', 'F'], // Level 7: CDEGAF (6 notes)
                    8: ['C', 'D', 'E', 'G', 'A', 'F'], // Level 8: CDEGAF (6 notes)
                    9: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Level 9: CDEFGAB (7 notes)
                    10: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Level 10: CDEFGAB (7 notes)
                    11: ['C', 'D', 'D#', 'E', 'F', 'G', 'A', 'B'], // Level 11: Add D# (8 notes)
                    12: ['C', 'D', 'D#', 'E', 'F', 'G', 'A', 'B'], // Level 12: Add D# (8 notes)
                    13: ['C', 'D', 'D#', 'E', 'F', 'G', 'G#', 'A', 'B'], // Level 13: Add G# (9 notes)
                    14: ['C', 'D', 'D#', 'E', 'F', 'G', 'G#', 'A', 'B'], // Level 14: Add G# (9 notes)
                    15: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B'], // Level 15: Add F# (10 notes)
                    16: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B'], // Level 16: Add F# (10 notes)
                    17: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 17: Add A# (11 notes)
                    18: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 18: Add A# (11 notes)
                    19: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 19: Add C# (12 notes - full chromatic)
                    20: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'] // Level 20: Full chromatic
                };

                // Different clock arrangements
                this.arrangements = {
                    chromatic: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                    fourths: ['C', 'F', 'A#', 'D#', 'G#', 'C#', 'F#', 'B', 'E', 'A', 'D', 'G'],
                    thirds: ['C', 'E', 'G#', 'C#', 'F', 'A', 'D', 'F#', 'A#', 'D#', 'G', 'B']
                };

                // Rhythm definitions - simplified
                this.rhythms = {
                    quarter: { taps: 1, symbol: '‚ô©', name: 'Quarter' },
                    eighth: { taps: 2, symbol: '‚ô´', name: 'Eighth' },
                    triplet: { taps: 3, symbol: '¬≥', name: 'Triplet' },
                    sixteenth: { taps: 4, symbol: '‚ô¨', name: 'Sixteenth' }
                };

                // Shepard tone frequencies for one octave
                this.notes = {
                    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
                    'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
                };

                this.initializeAudio();
                this.initializeEventListeners();
                this.updateEnabledRhythms(); // Initialize rhythm settings
                this.updateDisplay();
                this.updateClockArrangement();

                // Track active oscillators for cleanup
                this.activeOscillators = [];
            }

            async initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.setValueAtTime(0.8, this.audioContext.currentTime); // Increased volume
                } catch (error) {
                    console.error('Error initializing audio:', error);
                    alert('Audio initialization failed. Please try refreshing the page.');
                }
            }

            initializeEventListeners() {
                // Control buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopGame());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('listenAgainBtn').addEventListener('click', () => this.listenAgain());

                // Rhythm toggle controls
                document.getElementById('rhythmQuarter').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmEighth').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmTriplet').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmSixteenth').addEventListener('change', () => this.updateEnabledRhythms());

                // Scale type controls
                document.querySelectorAll('input[name="scaleType"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.usingCustomScale = e.target.value === 'custom';
                        const customContainer = document.getElementById('customScaleContainer');
                        customContainer.style.display = this.usingCustomScale ? 'block' : 'none';
                        this.updateClockArrangement();
                    });
                });

                // Custom note controls
                const noteCheckboxes = ['C', 'Csharp', 'D', 'Dsharp', 'E', 'F', 'Fsharp', 'G', 'Gsharp', 'A', 'Asharp', 'B'];
                noteCheckboxes.forEach(note => {
                    const checkbox = document.getElementById(`note${note}`);
                    if (checkbox) {
                        checkbox.addEventListener('change', () => this.updateCustomScale());
                    }
                });

                // Hide custom scale container when clicking outside
                document.addEventListener('click', (e) => {
                    const customContainer = document.getElementById('customScaleContainer');
                    const scaleControls = document.querySelector('.scale-controls');

                    // Check if click is outside the scale controls area and custom container is visible
                    if (this.usingCustomScale &&
                        customContainer &&
                        customContainer.style.display !== 'none' &&
                        !scaleControls.contains(e.target)) {

                        // Just hide the custom container, but keep custom mode active
                        customContainer.style.display = 'none';
                    }
                });

                // Light click events
                document.querySelectorAll('.light').forEach((light, index) => {
                    light.addEventListener('mousedown', (e) => this.onLightPress(index, e));
                    light.addEventListener('mouseup', (e) => this.onLightRelease(index, e));
                    light.addEventListener('mouseleave', (e) => this.onLightRelease(index, e));

                    // Touch events for mobile
                    light.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.onLightPress(index, e);
                    });
                    light.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.onLightRelease(index, e);
                    });
                });
            }

            // Stop all active audio
            stopAllAudio() {
                this.activeOscillators.forEach(osc => {
                    try {
                        if (osc && osc.stop) {
                            osc.stop();
                        }
                    } catch (e) {
                        // Oscillator may already be stopped
                    }
                });
                this.activeOscillators = [];
            }

            // User feedback tone with proper duration matching the rhythm
            playUserFeedbackTone(frequency, rhythmData) {
                if (!this.audioContext) return;

                try {
                    // Calculate the full duration this rhythm should have
                    const beatDuration = (60000 / this.bpm); // Keep in milliseconds
                    let subdivisionDuration = beatDuration / rhythmData.taps;

                    // Set minimum subdivision duration to prevent overlapping
                    const minSubdivisionDuration = 150; // Minimum 150ms between notes
                    if (subdivisionDuration < minSubdivisionDuration) {
                        subdivisionDuration = minSubdivisionDuration;
                    }

                    const noteDuration = (subdivisionDuration * 0.6) / 1000; // Convert to seconds, 60% for note

                    // Create Shepard tone with multiple octaves - same as sequence playback
                    const octaves = [1, 2, 4, 8]; // Four octaves
                    const gains = [0.3, 0.4, 0.4, 0.3]; // Bell curve weighting
                    const currentTime = this.audioContext.currentTime;

                    octaves.forEach((octaveMultiplier, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        // Set frequency for this octave
                        const octaveFreq = frequency * octaveMultiplier;
                        osc.frequency.setValueAtTime(octaveFreq, currentTime);
                        osc.type = 'sine';

                        // Envelope with proper decay length matching the rhythm
                        const maxGain = gains[index] * 0.18; // Slightly louder for user feedback
                        gain.gain.setValueAtTime(0, currentTime);
                        gain.gain.linearRampToValueAtTime(maxGain, currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(maxGain * 0.4, currentTime + noteDuration * 0.5);
                        gain.gain.exponentialRampToValueAtTime(0.001, currentTime + noteDuration);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        // Schedule start and stop
                        osc.start(currentTime);
                        osc.stop(currentTime + noteDuration);

                        // Track for cleanup
                        this.activeOscillators.push(osc);

                        // Remove from tracking when it naturally ends
                        osc.onended = () => {
                            const index = this.activeOscillators.indexOf(osc);
                            if (index > -1) {
                                this.activeOscillators.splice(index, 1);
                            }
                        };
                    });

                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }

            // Shepard tone generator with proper note durations
            playTone(frequency, noteDurationMs) {
                if (!this.audioContext) return;

                try {
                    // Convert milliseconds to seconds
                    const noteDuration = noteDurationMs / 1000;

                    // Create Shepard tone with multiple octaves
                    const octaves = [1, 2, 4, 8]; // Four octaves
                    const gains = [0.3, 0.4, 0.4, 0.3]; // Bell curve weighting
                    const currentTime = this.audioContext.currentTime;

                    octaves.forEach((octaveMultiplier, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        // Set frequency for this octave
                        const octaveFreq = frequency * octaveMultiplier;
                        osc.frequency.setValueAtTime(octaveFreq, currentTime);
                        osc.type = 'sine';

                        // Envelope with decay
                        const maxGain = gains[index] * 0.12; // Reduced volume further
                        gain.gain.setValueAtTime(0, currentTime);
                        gain.gain.linearRampToValueAtTime(maxGain, currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(maxGain * 0.4, currentTime + noteDuration * 0.5);
                        gain.gain.exponentialRampToValueAtTime(0.001, currentTime + noteDuration);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        // Schedule start and stop
                        osc.start(currentTime);
                        osc.stop(currentTime + noteDuration);

                        // Track for cleanup
                        this.activeOscillators.push(osc);

                        // Remove from tracking when it naturally ends
                        osc.onended = () => {
                            const index = this.activeOscillators.indexOf(osc);
                            if (index > -1) {
                                this.activeOscillators.splice(index, 1);
                            }
                        };
                    });

                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }

            // Update enabled rhythms based on checkboxes
            updateEnabledRhythms() {
                this.enabledRhythms = [];
                if (document.getElementById('rhythmQuarter').checked) this.enabledRhythms.push('quarter');
                if (document.getElementById('rhythmEighth').checked) this.enabledRhythms.push('eighth');
                if (document.getElementById('rhythmTriplet').checked) this.enabledRhythms.push('triplet');
                if (document.getElementById('rhythmSixteenth').checked) this.enabledRhythms.push('sixteenth');

                // Ensure at least one rhythm is enabled
                if (this.enabledRhythms.length === 0) {
                    this.enabledRhythms.push('quarter');
                    document.getElementById('rhythmQuarter').checked = true;
                }
            }

            // Update custom scale based on note checkboxes
            updateCustomScale() {
                this.customNotes = [];
                const noteMap = {
                    'C': 'C', 'Csharp': 'C#', 'D': 'D', 'Dsharp': 'D#',
                    'E': 'E', 'F': 'F', 'Fsharp': 'F#', 'G': 'G',
                    'Gsharp': 'G#', 'A': 'A', 'Asharp': 'A#', 'B': 'B'
                };

                Object.keys(noteMap).forEach(checkboxId => {
                    const checkbox = document.getElementById(`note${checkboxId}`);
                    if (checkbox && checkbox.checked) {
                        this.customNotes.push(noteMap[checkboxId]);
                    }
                });

                // Ensure at least one note is selected
                if (this.customNotes.length === 0) {
                    this.customNotes.push('C');
                    document.getElementById('noteC').checked = true;
                }

                this.updateClockArrangement();
            }

            // Update clock arrangement based on selected pattern
            updateClockArrangement() {
                const arrangement = this.arrangements[this.currentArrangement];
                const lights = document.querySelectorAll('.light');
                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);

                // Always use linear layout for a cleaner, more kid-friendly look
                const container = document.querySelector('.clock-container');
                container.classList.add('linear-layout');
                container.classList.remove('circular-layout');

                // Reset container styles for linear layout
                container.style.width = 'auto';
                container.style.height = '180px';

                let visibleIndex = 0;
                lights.forEach((light, index) => {
                    const noteForPosition = arrangement[index];
                    light.dataset.note = noteForPosition;
                    light.querySelector('.light-number').textContent = noteForPosition;

                    if (availableNotes.includes(noteForPosition)) {
                        light.style.display = 'flex';
                        light.style.opacity = '1';
                        light.style.pointerEvents = 'auto';

                        // Remove any inline positioning for linear layout
                        light.style.left = '';
                        light.style.top = '';
                        light.style.transform = '';

                        visibleIndex++;
                    } else {
                        light.style.display = 'none';
                    }
                });
            }            // Get available notes for current level
            getAvailableNotesForLevel(level = null) {
                if (this.usingCustomScale) {
                    return this.customNotes;
                }
                // Use current level, not round
                const currentLevel = level || this.currentLevel;
                const clampedLevel = Math.min(currentLevel, 10);
                return this.levelNotes[clampedLevel] || this.levelNotes[10];
            }

            // Generate random sequence item - only from available notes and enabled rhythms
            generateSequenceItem() {
                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                const arrangement = this.arrangements[this.currentArrangement];

                // Find positions that have available notes
                const availablePositions = [];
                arrangement.forEach((note, index) => {
                    if (availableNotes.includes(note)) {
                        availablePositions.push(index);
                    }
                });

                if (availablePositions.length === 0) {
                    // Fallback to position 0 if no notes available
                    availablePositions.push(0);
                }

                let lightIndex;

                // Improved randomization to avoid repetitive patterns
                if (this.lastNoteIndex === -1 || availablePositions.length <= 2) {
                    // First note or very few options - pick randomly
                    lightIndex = availablePositions[Math.floor(Math.random() * availablePositions.length)];
                } else {
                    // Create weighted selection to encourage variety
                    const weights = [];
                    const recentNotes = this.gameSequence.slice(-3).map(item => item.lightIndex); // Last 3 notes

                    for (const pos of availablePositions) {
                        if (pos === this.lastNoteIndex) {
                            // Never repeat the immediate previous note
                            continue;
                        }

                        let weight = 1.0;

                        // Reduce weight if note was used recently (within last 3)
                        const recentCount = recentNotes.filter(recent => recent === pos).length;
                        if (recentCount > 0) {
                            weight = 0.3; // Much lower weight for recently used notes
                        }

                        // Slightly favor notes that haven't been used at all yet
                        const usedInSequence = this.gameSequence.some(item => item.lightIndex === pos);
                        if (!usedInSequence) {
                            weight += 0.5; // Bonus for unused notes
                        }

                        weights.push({ pos, weight });
                    }

                    // If all notes are heavily weighted down, reset to equal weights
                    if (weights.length === 0 || weights.every(w => w.weight < 0.5)) {
                        lightIndex = availablePositions.filter(pos => pos !== this.lastNoteIndex)[0] ||
                            availablePositions[Math.floor(Math.random() * availablePositions.length)];
                    } else {
                        // Weighted random selection
                        const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
                        let random = Math.random() * totalWeight;

                        for (const w of weights) {
                            random -= w.weight;
                            if (random <= 0) {
                                lightIndex = w.pos;
                                break;
                            }
                        }

                        // Fallback if something went wrong
                        if (lightIndex === undefined) {
                            lightIndex = weights[0].pos;
                        }
                    }
                }

                // Store this position for next time
                this.lastNoteIndex = lightIndex;

                // Improved rhythm randomization - favor variety
                const enabledRhythmKeys = this.enabledRhythms;
                let rhythmKey;

                if (this.gameSequence.length === 0) {
                    // First item - any rhythm is fine
                    rhythmKey = enabledRhythmKeys[Math.floor(Math.random() * enabledRhythmKeys.length)];
                } else {
                    // Check last few rhythms to encourage variety
                    const recentRhythms = this.gameSequence.slice(-2).map(item => item.rhythm);
                    const availableRhythms = enabledRhythmKeys.filter(r => !recentRhythms.includes(r));

                    if (availableRhythms.length > 0 && Math.random() < 0.7) {
                        // 70% chance to use a rhythm that wasn't used recently
                        rhythmKey = availableRhythms[Math.floor(Math.random() * availableRhythms.length)];
                    } else {
                        // 30% chance to use any rhythm (allows some repetition)
                        rhythmKey = enabledRhythmKeys[Math.floor(Math.random() * enabledRhythmKeys.length)];
                    }
                }

                const light = document.getElementById(`light-${lightIndex}`);
                const note = light.dataset.note;

                return {
                    lightIndex,
                    note,
                    rhythm: rhythmKey,
                    rhythmData: this.rhythms[rhythmKey]
                };
            }

            // Start new game - faster setup
            async startGame() {
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.gameState = 'playing';
                this.playerSequence = [];
                this.currentRound = 1;
                this.currentLevel = 1; // Reset to level 1
                this.correctInRow = 0; // Reset progression counter
                this.bpm = 50; // Reset BPM to starting value (50 BPM)
                this.lastNoteIndex = -1; // Reset note tracking
                this.lives = 3; // Reset lives to 3

                // Start with one simple item
                this.gameSequence = [this.generateSequenceItem()];

                // Reset scoring
                this.totalScore = 0;
                this.levelScore = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.currentLevelRhythmBonus = 0; // Reset rhythm bonus for new game
                this.listenAgainUsed = false; // Reset Listen Again for new game

                this.updateDisplay();
                this.updateControls();
                this.updateClockArrangement(); // Ensure proper arrangement for level 1

                // Start playing with minimal delay
                setTimeout(() => {
                    this.playSequence();
                }, 300); // Reduced from 500ms to 300ms
            }

            // Stop game
            stopGame() {
                this.gameState = 'stopped';
                this.stopAllAudio(); // Stop any playing audio
                this.clearAllTimeouts();
                this.clearAllLights();
                this.updateDisplay();
                this.updateControls();
            }

            // Reset game
            resetGame() {
                this.stopGame();
                this.gameSequence = [];
                this.playerSequence = [];
                this.currentRound = 1;
                this.currentLevel = 1; // Reset to level 1
                this.correctInRow = 0; // Reset progression counter
                this.bpm = 50; // Reset BPM to starting value (50 BPM)
                this.lastNoteIndex = -1; // Reset note tracking
                this.lives = 3; // Reset lives to 3
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.updateDisplay();
                this.updateClockArrangement(); // Refresh clock for level 1
                this.updateControls(); // Update button states
            }

            // Play sequence - each round is exactly 1 beat duration
            playSequence() {
                this.gameState = 'playing';
                this.updateDisplay();

                let delay = 0;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                this.gameSequence.forEach((item, index) => {
                    setTimeout(() => {
                        this.playSequenceItem(item);
                    }, delay);

                    // Each round takes exactly one beat duration, regardless of subdivisions
                    delay += beatDuration; // No gaps - each round is exactly 1 beat
                });

                // Switch to player turn after sequence completes - no extra delay
                setTimeout(() => {
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls(); // Update button states including Listen Again
                }, delay); // Removed the +200ms delay
            }

            // Play individual sequence item - subdivisions within one beat with proper timing
            playSequenceItem(item) {
                const light = document.getElementById(`light-${item.lightIndex}`);
                const frequency = this.notes[item.note];
                const tapsToPlay = item.rhythmData.taps;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                // Calculate subdivision timing within the beat
                let subdivisionDuration = beatDuration / tapsToPlay; // Each tap gets equal share of the beat

                // Set minimum subdivision duration to prevent overlapping (especially for 16th notes)
                const minSubdivisionDuration = 150; // Minimum 150ms between notes
                if (subdivisionDuration < minSubdivisionDuration) {
                    subdivisionDuration = minSubdivisionDuration;
                }

                const noteDuration = subdivisionDuration * 0.6; // 60% of subdivision for note (reduced to prevent overlap)
                const gapDuration = subdivisionDuration * 0.4; // 40% gap (increased for cleaner separation)

                // Visual and audio for each subdivision
                for (let i = 0; i < tapsToPlay; i++) {
                    setTimeout(() => {
                        // Visual flash - duration matches note duration (only 'playing' class for sequence)
                        light.classList.add('playing');
                        setTimeout(() => {
                            light.classList.remove('playing');
                        }, noteDuration);

                        // Audio with Shepard tone and proper duration
                        this.playTone(frequency, noteDuration); // Use noteDuration instead of subdivisionDuration
                    }, i * subdivisionDuration);
                }
            }

            // Listen Again function - replay current sequence once per level
            listenAgain() {
                if (this.listenAgainUsed || this.gameState !== 'listening' || !this.isPlayerTurn) {
                    return; // Can't use if already used, not in listening state, or not player turn
                }

                // Mark as used for this level
                this.listenAgainUsed = true;

                // Temporarily disable player turn and replay sequence
                this.isPlayerTurn = false;
                this.gameState = 'playing';
                this.updateControls(); // Update button states

                // Replay the current sequence
                this.playSequence();
            }

            // Handle light press - simplified validation with timing tolerance
            onLightPress(lightIndex, event) {
                if (!this.isPlayerTurn) return;

                const expectedItem = this.gameSequence[this.currentSequenceIndex];
                if (!expectedItem) return;

                // Check correct light
                if (lightIndex !== expectedItem.lightIndex) {
                    this.loseLife();
                    return;
                }

                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.add('active');

                // PLAY AUDIO FEEDBACK with proper duration matching the expected rhythm
                const note = light.dataset.note;
                const frequency = this.notes[note];
                this.playUserFeedbackTone(frequency, expectedItem.rhythmData);

                // Track timing for validation - start timing from first note press
                if (this.currentTapCount === 0) {
                    this.tapStartTime = Date.now();
                    this.currentItemStartTime = Date.now(); // Track when this item started
                }

                this.currentTapCount++;

                // Check if we've got enough taps
                const requiredTaps = expectedItem.rhythmData.taps;
                if (this.currentTapCount >= requiredTaps) {
                    // Basic validation - ensure correct number of taps
                    if (this.currentTapCount > 1) {
                        const totalTime = Date.now() - this.tapStartTime;
                        const beatDuration = 60000 / this.bpm; // Duration of one beat in ms
                        const expectedTime = (requiredTaps - 1) * (beatDuration / requiredTaps); // Subdivisions within beat

                        // Basic acceptance tolerance (50%) - too slow fails
                        const basicTolerance = expectedTime * 0.5;
                        if (totalTime > expectedTime + basicTolerance) {
                            this.loseLife();
                            return;
                        }
                    }

                    // No rhythm scoring here - only done at end of full sequence                    // Success! Move to next item
                    this.playerSequence.push({
                        lightIndex,
                        note: light.dataset.note,
                        rhythm: expectedItem.rhythm,
                        tapCount: this.currentTapCount,
                        startTime: this.currentItemStartTime,
                        endTime: Date.now()
                    });

                    this.currentSequenceIndex++;
                    this.currentTapCount = 0;

                    // Check if sequence complete
                    if (this.currentSequenceIndex >= this.gameSequence.length) {
                        // Calculate rhythm bonus for the ENTIRE sequence timing
                        this.calculateSequenceRhythmBonus();
                        setTimeout(() => this.nextRound(), 500);
                    }
                }

                this.playerPressedLight = lightIndex;
            }

            // Handle light release - No beeping
            onLightRelease(lightIndex, event) {
                if (!this.isPlayerTurn || this.playerPressedLight !== lightIndex) return;

                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.remove('active');

                this.playerPressedLight = null;
            }

            // Calculate rhythm bonus for the entire sequence timing
            calculateSequenceRhythmBonus() {
                if (this.playerSequence.length < 2) {
                    // Single note sequences don't get rhythm bonus
                    return;
                }

                // Calculate expected timing for the entire sequence: (n-1) beats total
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms
                const expectedTotalTime = (this.gameSequence.length - 1) * beatDuration;

                // Get actual timing from player sequence
                const firstItemTime = this.playerSequence[0].startTime || Date.now();
                const lastItemTime = this.playerSequence[this.playerSequence.length - 1].endTime || Date.now();
                const actualTotalTime = lastItemTime - firstItemTime;

                // Check overall sequence timing first - much stricter validation
                let overallTimingAccuracy = 0;
                if (expectedTotalTime > 0) {
                    // Calculate how far off the player was from perfect timing
                    const timingError = Math.abs(actualTotalTime - expectedTotalTime);
                    const maxAllowedError = expectedTotalTime * 0.15; // Only 15% tolerance for timing

                    if (timingError <= maxAllowedError) {
                        // Within acceptable range - calculate accuracy
                        overallTimingAccuracy = 1 - (timingError / maxAllowedError);
                    } else {
                        // Too far off - no accuracy bonus
                        overallTimingAccuracy = 0;
                    }
                }

                // Now check individual rhythm accuracy for each note
                let rhythmAccuracyCount = 0;
                let totalRhythmChecks = 0;

                for (let i = 0; i < this.playerSequence.length; i++) {
                    const playerItem = this.playerSequence[i];
                    const expectedItem = this.gameSequence[i];

                    // Skip rhythm check for quarter notes (single tap)
                    if (expectedItem.rhythmData.taps === 1) {
                        rhythmAccuracyCount++; // Quarter notes are always "accurate"
                        totalRhythmChecks++;
                        continue;
                    }

                    // For multi-tap rhythms, check if player timing matches expected subdivisions
                    const expectedSubdivisionTime = beatDuration / expectedItem.rhythmData.taps;

                    // Calculate player's rhythm timing for this note
                    const playerRhythmTime = playerItem.endTime - playerItem.startTime;
                    const expectedRhythmTime = (expectedItem.rhythmData.taps - 1) * expectedSubdivisionTime;

                    // Much stricter rhythm timing - only 10% tolerance for multi-tap rhythms
                    const rhythmTolerance = expectedRhythmTime * 0.1;
                    if (Math.abs(playerRhythmTime - expectedRhythmTime) <= rhythmTolerance) {
                        rhythmAccuracyCount++;
                    }
                    totalRhythmChecks++;
                }

                // Calculate final rhythm accuracy percentage
                const rhythmAccuracy = totalRhythmChecks > 0 ? rhythmAccuracyCount / totalRhythmChecks : 1;

                // Combine overall timing and rhythm accuracy (both must be good)
                const finalAccuracy = Math.min(overallTimingAccuracy, rhythmAccuracy);

                console.log(`Overall Timing: ${(overallTimingAccuracy * 100).toFixed(1)}%, Rhythm Accuracy: ${(rhythmAccuracy * 100).toFixed(1)}%, Final: ${(finalAccuracy * 100).toFixed(1)}%`);
                console.log(`Expected Total: ${expectedTotalTime}ms, Actual Total: ${actualTotalTime}ms`);

                // Award rhythm bonus based on combined accuracy - much stricter thresholds
                let rhythmBonus = 0;
                if (this.currentLevelRhythmBonus < 250) {
                    if (finalAccuracy >= 0.95) {
                        // Within 95% = 250 bonus (was 90%)
                        rhythmBonus = Math.min(250, 250 - this.currentLevelRhythmBonus);
                        this.perfectTimingCount++;
                    } else if (finalAccuracy >= 0.85) {
                        // Within 85% = 100 bonus (was 75%)
                        rhythmBonus = Math.min(100, 250 - this.currentLevelRhythmBonus);
                    } else if (finalAccuracy >= 0.7) {
                        // Within 70% = 50 bonus (was 50%)
                        rhythmBonus = Math.min(50, 250 - this.currentLevelRhythmBonus);
                    }
                }

                // Store bonus but DON'T add to total score yet - only add to level tracking
                if (rhythmBonus > 0) {
                    this.levelScore += rhythmBonus; // Track for level display only
                    this.currentLevelRhythmBonus += rhythmBonus; // Track rhythm bonus for this level
                    // DON'T add to totalScore here - only at end of level
                }

                this.totalTimingAttempts++;
            }

            // Detect rhythm based on duration
            detectRhythm(beats) {
                const rhythmEntries = Object.entries(this.rhythms);
                let closestRhythm = 'quarter';
                let smallestDiff = Infinity;

                // Don't auto-detect triplets, they're handled separately
                rhythmEntries.forEach(([key, data]) => {
                    if (key === 'triplet') return;
                    const diff = Math.abs(beats - data.beats);
                    if (diff < smallestDiff) {
                        smallestDiff = diff;
                        closestRhythm = key;
                    }
                });

                return closestRhythm;
            }

            // Advance to next round - Level progression based on sequence length
            nextRound() {
                // Check if we should advance to next level (based on sequence length)
                const targetSequenceLength = this.levelRequirements[this.currentLevel];
                if (this.gameSequence.length >= targetSequenceLength && this.currentLevel < 20) {
                    const newLevel = this.currentLevel + 1;
                    this.currentLevel = newLevel;
                    this.correctInRow = 0; // Reset counter for new level
                    this.bpm = Math.min(50 + (newLevel - 1) * 2, 85); // 2 BPM per level, max 85
                    this.lastNoteIndex = -1; // Reset note tracking for new level
                    this.listenAgainUsed = false; // Reset Listen Again for new level

                    // Show level completion celebration
                    this.showLevelCelebration(newLevel);
                    return; // Exit early, celebration will continue the game
                } else {
                    // Same level, continue building sequence
                    this.currentRound++;
                    // Add ONE new item to the existing sequence (Simon Says behavior)
                    this.gameSequence.push(this.generateSequenceItem());
                }

                // Reset player sequence for the new round
                this.playerSequence = [];
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.isPlayerTurn = false;

                this.updateDisplay();

                // Reduced pause before playing the ENTIRE sequence again
                setTimeout(() => {
                    this.playSequence();
                }, 800); // Reduced from 1500ms to 800ms
            }

            // Lose a life - restart the same level
            loseLife() {
                this.lives--;
                this.updateDisplay();

                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Show "Try Again" modal and replay sequence
                    this.showTryAgainModal();
                }
            }

            // Game over
            gameOver() {
                this.gameState = 'stopped';
                this.isPlayerTurn = false;
                this.correctInRow = 0; // Reset on game over
                this.lives = 3; // Reset lives for next game
                // No metronome to stop
                this.updateDisplay();
                this.updateControls();

                alert(`Game Over! You reached round ${this.currentRound}, Level ${this.currentLevel}`);
            }

            // Start a new round with a fresh sequence for the current level
            startRound() {
                // Generate a new single-item sequence for the current level
                this.gameSequence = [this.generateSequenceItem()];
                this.playerSequence = [];
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.isPlayerTurn = false;

                this.updateDisplay();
                this.updateClockArrangement();

                // Start playing the sequence
                setTimeout(() => {
                    this.playSequence();
                }, 300);
            }

            // Update display elements
            updateDisplay() {
                document.getElementById('totalScore').textContent = this.totalScore.toLocaleString();
                document.getElementById('round').textContent = this.currentRound;
                document.getElementById('lives').textContent = this.lives;

                // Keep the footer simple and fun for kids - no complex info!
            }

            // Level completion celebration with sound and visual effects
            showLevelCelebration(newLevel) {
                // Calculate level scores
                const baseScore = 100; // 100 points for completing level
                const noteBonus = this.gameSequence.length * 50; // 50 points per note
                // rhythmBonus is already added to levelScore in calculateSequenceRhythmBonus

                // Base level score without rhythm bonus
                const baseLevelScore = baseScore + noteBonus;
                const rhythmBonus = this.currentLevelRhythmBonus; // Use the tracked rhythm bonus for this level

                this.levelScore = baseLevelScore + rhythmBonus; // Ensure correct total
                this.totalScore += this.levelScore; // Add ENTIRE level score to total at end of level

                // Play kids cheering sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const cheeringAudio = new Audio('kids-cheering-sound-effect.mp3');
                    cheeringAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Create celebration overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    font-family: 'Comic Sans MS', 'Trebuchet MS', 'Lucida Grande', Arial, sans-serif;
                `;

                // Level title
                const celebrationText = document.createElement('div');
                celebrationText.textContent = `LEVEL ${newLevel}!`;
                celebrationText.style.cssText = `
                    font-size: 72px;
                    font-weight: 900;
                    color: white;
                    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
                    text-align: center;
                    animation: colorCycle 0.5s ease-in-out infinite alternate;
                    margin-bottom: 30px;
                `;

                // Score breakdown container
                const scoreContainer = document.createElement('div');
                scoreContainer.style.cssText = `
                    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
                    background-size: 400% 400%;
                    padding: 30px;
                    border-radius: 20px;
                    border: 4px solid white;
                    text-align: center;
                    animation: gradientShift 2s ease infinite;
                    min-width: 400px;
                `;

                // Individual score lines
                const scoreLines = [
                    { text: `Level Complete: +${baseScore}`, delay: 200 },
                    { text: `${this.gameSequence.length} Notes: +${noteBonus}`, delay: 600 },
                    rhythmBonus > 0 ? { text: `Rhythm Accuracy Bonus: +${rhythmBonus}`, delay: 1000 } : null,
                    { text: `Total Level: ${this.levelScore}`, delay: rhythmBonus > 0 ? 1400 : 1000, isTotal: true },
                    { text: `Grand Total: ${this.totalScore.toLocaleString()}`, delay: rhythmBonus > 0 ? 1800 : 1400, isGrandTotal: true }
                ].filter(Boolean);

                scoreLines.forEach((scoreData, index) => {
                    const scoreLine = document.createElement('div');
                    scoreLine.style.cssText = `
                        font-size: ${scoreData.isGrandTotal ? '36px' : scoreData.isTotal ? '28px' : '24px'};
                        font-weight: 900;
                        color: ${scoreData.isGrandTotal ? '#ff1744' : scoreData.isTotal ? '#00e676' : 'white'};
                        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                        margin: 8px 0;
                        opacity: 0;
                        transform: translateY(20px);
                        animation: scoreReveal 0.5s ease forwards;
                        animation-delay: ${scoreData.delay}ms;
                        ${scoreData.isGrandTotal ? 'border-top: 3px solid white; padding-top: 15px; margin-top: 20px;' : ''}
                    `;
                    scoreLine.textContent = scoreData.text;
                    scoreContainer.appendChild(scoreLine);
                });

                // Add rainbow color cycling animation and score reveal animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes colorCycle {
                        0% { color: #ff0000; }
                        16.67% { color: #ff8000; }
                        33.33% { color: #ffff00; }
                        50% { color: #00ff00; }
                        66.67% { color: #0080ff; }
                        83.33% { color: #8000ff; }
                        100% { color: #ff0080; }
                    }
                    @keyframes gradientShift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }
                    @keyframes scoreReveal {
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }
                `;
                document.head.appendChild(style);

                overlay.appendChild(celebrationText);
                overlay.appendChild(scoreContainer);
                document.body.appendChild(overlay);

                // Remove celebration after 3.5 seconds and continue game
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);

                    // Reset level scoring for next level
                    this.levelScore = 0;
                    this.perfectTimingCount = 0;
                    this.totalTimingAttempts = 0;
                    this.currentLevelRhythmBonus = 0; // Reset rhythm bonus for new level
                    this.listenAgainUsed = false; // Reset Listen Again for new level

                    // Continue with level progression
                    this.gameSequence = [this.generateSequenceItem()];
                    this.currentRound = 1; // Reset round counter for new level
                    this.updateClockArrangement(); // Update available notes for new level
                    this.updateDisplay();

                    // Start the new level's sequence after a brief pause
                    setTimeout(() => {
                        this.playSequence();
                    }, 500);
                }, 3500);
            }            // Show "Try Again" modal and replay sequence until correct
            showTryAgainModal() {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    font-family: 'Comic Sans MS', 'Trebuchet MS', 'Lucida Grande', Arial, sans-serif;
                `;

                const modalText = document.createElement('div');
                modalText.textContent = 'Try Again';
                modalText.style.cssText = `
                    font-size: 48px;
                    font-weight: 900;
                    color: #ff6b6b;
                    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
                    text-align: center;
                    background: white;
                    padding: 40px 60px;
                    border-radius: 20px;
                    border: 4px solid #ff6b6b;
                `;

                overlay.appendChild(modalText);
                document.body.appendChild(overlay);

                // Remove modal after 1 second and replay sequence
                setTimeout(() => {
                    document.body.removeChild(overlay);

                    // Reset player input position but keep same sequence
                    this.playerIndex = 0;
                    this.isPlayerTurn = false;
                    this.gameState = 'playing';

                    // Replay the same sequence after brief pause
                    setTimeout(() => {
                        this.playSequence();
                    }, 500);
                }, 1000);
            }

            // Update control buttons
            updateControls() {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const listenAgainBtn = document.getElementById('listenAgainBtn');
                const scaleRadios = document.querySelectorAll('input[name="scaleType"]');

                if (this.gameState === 'stopped') {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    listenAgainBtn.disabled = true;
                    // Enable scale selection when game is stopped
                    scaleRadios.forEach(radio => radio.disabled = false);
                } else {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;

                    // Listen Again button: enabled only during listening state, not used yet this level
                    listenAgainBtn.disabled = !(this.gameState === 'listening' && this.isPlayerTurn && !this.listenAgainUsed);

                    // Disable scale selection during active game
                    scaleRadios.forEach(radio => radio.disabled = true);
                }
            }

            // Clear all timeouts
            clearAllTimeouts() {
                if (this.sequenceTimeout) {
                    clearTimeout(this.sequenceTimeout);
                    this.sequenceTimeout = null;
                }
                if (this.playerTimeout) {
                    clearTimeout(this.playerTimeout);
                    this.playerTimeout = null;
                }
            }

            // Clear all light effects
            clearAllLights() {
                document.querySelectorAll('.light').forEach(light => {
                    light.classList.remove('active', 'playing');
                });
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new MemoryRhythmGame();
        });
    </script>
</body>

</html>
