<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Match</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="game-container">
        <header class="game-header">
            <h1>ğŸµ Music Match ğŸµ</h1>
            <div class="game-info">
                <div class="score">Score: <span id="totalScore">0</span></div>
                <div class="score">Round: <span id="round">1</span></div>
                <div class="score">Lives: <span id="lives">3</span></div>
            </div>
            <div class="controls">
                <button id="startBtn" class="btn primary">ğŸ® Start Game</button>
                <button id="stopBtn" class="btn secondary" disabled>ğŸ›‘ Stop</button>
                <button id="resetBtn" class="btn secondary">ğŸ”„ Reset</button>
                <button id="listenAgainBtn" class="btn special" disabled>ğŸ‘‚ Listen Again</button>
            </div>
            <div class="rhythm-controls">
                <h4>ğŸµ Rhythm Options:</h4>
                <div class="rhythm-toggles">
                    <label><input type="checkbox" id="rhythmQuarter" checked> â™© - Â¹â„â‚„ notes (ğŸŸ£ PLUM) </label>
                    <label><input type="checkbox" id="rhythmEighth"> â™« - Â¹â„â‚ˆ notes (ğŸAPPLE) </label>
                </div>
                <div class="rhythm-toggles" style="margin-top: 10px;">
                    <label><input type="checkbox" id="rhythmTriplet"> Â³ - Triplets (ğŸPINEAPPLE) </label>
                    <label><input type="checkbox" id="rhythmSixteenth"> â™¬ - Â¹â„â‚â‚† notes (ğŸ‰WATERMELON) </label>
                </div>
            </div>
            <div class="scale-controls">
                <h4>ğŸ¹ Note Options:</h4>
                <div class="scale-options">
                    <label><input type="radio" name="scaleType" value="progressive" checked> ğŸ˜ Fun Levels</label>
                    <label><input type="radio" name="scaleType" value="custom"> ğŸ¨ My Own Notes</label>
                    <label><input type="checkbox" id="muteCheeringSound" checked> ğŸ”Š Sound FX</label>
                </div>
                <div class="game-mode-options" style="margin-top: 10px;">
                    <label><input type="checkbox" id="callResponseMode"> ğŸ‘¥ Call & Response (2 Players)</label>
                    <label><input type="checkbox" id="pitchTrainingMode"> ğŸ¯ Pitch Training</label>
                </div>
                <div class="custom-scale" id="customScaleContainer" style="display: none;">
                    <div class="note-toggles">
                        <label><input type="checkbox" id="noteC" checked> C</label>
                        <label><input type="checkbox" id="noteCsharp"> C#</label>
                        <label><input type="checkbox" id="noteD"> D</label>
                        <label><input type="checkbox" id="noteDsharp"> D#</label>
                        <label><input type="checkbox" id="noteE" checked> E</label>
                        <label><input type="checkbox" id="noteF"> F</label>
                        <label><input type="checkbox" id="noteFsharp"> F#</label>
                        <label><input type="checkbox" id="noteG" checked> G</label>
                        <label><input type="checkbox" id="noteGsharp"> G#</label>
                        <label><input type="checkbox" id="noteA"> A</label>
                        <label><input type="checkbox" id="noteAsharp"> A#</label>
                        <label><input type="checkbox" id="noteB"> B</label>
                    </div>
                </div>
            </div>
        </header>

        <main class="game-board">
            <div class="notes-container">
                <!-- 12 Colored lights for chromatic scale notes -->
                <div class="light" id="light-0" data-note="C">
                    <span class="light-number">C</span>
                </div>
                <div class="light" id="light-1" data-note="C#">
                    <span class="light-number">C#</span>
                </div>
                <div class="light" id="light-2" data-note="D">
                    <span class="light-number">D</span>
                </div>
                <div class="light" id="light-3" data-note="D#">
                    <span class="light-number">D#</span>
                </div>
                <div class="light" id="light-4" data-note="E">
                    <span class="light-number">E</span>
                </div>
                <div class="light" id="light-5" data-note="F">
                    <span class="light-number">F</span>
                </div>
                <div class="light" id="light-6" data-note="F#">
                    <span class="light-number">F#</span>
                </div>
                <div class="light" id="light-7" data-note="G">
                    <span class="light-number">G</span>
                </div>
                <div class="light" id="light-8" data-note="G#">
                    <span class="light-number">G#</span>
                </div>
                <div class="light" id="light-9" data-note="A">
                    <span class="light-number">A</span>
                </div>
                <div class="light" id="light-10" data-note="A#">
                    <span class="light-number">A#</span>
                </div>
                <div class="light" id="light-11" data-note="B">
                    <span class="light-number">B</span>
                </div>
            </div>
        </main>
    </div>

    <script>// Memory Rhythm Game - Main JavaScript File

        class MemoryRhythmGame {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.gameSequence = [];
                this.playerSequence = [];
                this.currentRound = 1;
                this.gameState = 'stopped'; // 'stopped', 'playing', 'listening', 'waiting'
                this.bpm = 50; // Start at 50 BPM, increases by 2 per level, max 85
                this.sequenceTimeout = null;
                this.playerTimeout = null;
                this.isPlayerTurn = false;
                this.currentSequenceIndex = 0; // Track which item in sequence player is on
                this.currentTapCount = 0; // Track taps for current item
                this.tapStartTime = 0; // Track when player started tapping current item
                this.currentItemStartTime = 0; // Track when current sequence item started
                this.usingCustomScale = false; // Track if using custom scale
                this.customNotes = ['C', 'E', 'G']; // Default custom scale
                this.enabledRhythms = ['quarter']; // Start with only quarters - super simple
                this.currentLevel = 1; // Current level (affects available notes)
                this.correctInRow = 0; // Track consecutive correct answers
                this.lastNoteIndex = -1; // Track last note to avoid repetition
                this.lives = 3; // Start with 3 lives

                // Game mode settings
                this.callResponseMode = false; // 2-player call and response mode
                this.pitchTrainingMode = false; // Pitch training mode
                this.isPlayer1Turn = true; // Track whose turn in call and response
                this.player1Sequence = []; // Store player 1's performance for comparison
                this.pitchTrainingListenCount = 0; // Track Listen Again uses in pitch training
                this.callResponseRound = 1; // Track round number for call & response mode

                // Scoring system
                this.totalScore = 0;
                this.levelScore = 0;
                this.rhythmAccuracy = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.currentLevelRhythmBonus = 0; // Track rhythm bonus for current level only
                this.listenAgainUsed = false; // Track if Listen Again has been used this level

                // Level requirements: sequence length progression (3â†’4â†’4â†’5â†’5â†’6â†’6â†’7 etc.)
                this.levelRequirements = {
                    1: 3, // Level 1: 3 notes to complete
                    2: 4, // Level 2: 4 notes to complete
                    3: 4, // Level 3: 4 notes to complete (including A)
                    4: 5, // Level 4: 5 notes to complete
                    5: 5, // Level 5: 5 notes to complete
                    6: 6, // Level 6: 6 notes to complete  
                    7: 6, // Level 7: 6 notes to complete
                    8: 7, // Level 8: 7 notes to complete
                    9: 7, // Level 9: 7 notes to complete
                    10: 8, // Level 10: 8 notes to complete
                    11: 8, // Level 11: 8 notes to complete
                    12: 9, // Level 12: 9 notes to complete
                    13: 9, // Level 13: 9 notes to complete
                    14: 10, // Level 14: 10 notes to complete
                    15: 10, // Level 15: 10 notes to complete
                    16: 11, // Level 16: 11 notes to complete
                    17: 11, // Level 17: 11 notes to complete
                    18: 12, // Level 18: 12 notes to complete (max)
                    19: 12, // Level 19: 12 notes to complete
                    20: 12 // Level 20: 12 notes to complete
                };

                // Progressive note system by level - slower progression
                this.levelNotes = {
                    1: ['C', 'E', 'G'], // Level 1: CEG (3 notes)
                    2: ['C', 'E', 'G'], // Level 2: CEG (3 notes) 
                    3: ['C', 'E', 'G', 'A'], // Level 3: CEGA (4 notes)
                    4: ['C', 'E', 'G', 'A'], // Level 4: CEGA (4 notes)
                    5: ['C', 'E', 'G', 'A', 'D'], // Level 5: CEGAD (5 notes)
                    6: ['C', 'E', 'G', 'A', 'D'], // Level 6: CEGAD (5 notes)
                    7: ['C', 'D', 'E', 'G', 'A', 'F'], // Level 7: CDEGAF (6 notes)
                    8: ['C', 'D', 'E', 'G', 'A', 'F'], // Level 8: CDEGAF (6 notes)
                    9: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Level 9: CDEFGAB (7 notes)
                    10: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Level 10: CDEFGAB (7 notes)
                    11: ['C', 'D', 'D#', 'E', 'F', 'G', 'A', 'B'], // Level 11: Add D# (8 notes)
                    12: ['C', 'D', 'D#', 'E', 'F', 'G', 'A', 'B'], // Level 12: Add D# (8 notes)
                    13: ['C', 'D', 'D#', 'E', 'F', 'G', 'G#', 'A', 'B'], // Level 13: Add G# (9 notes)
                    14: ['C', 'D', 'D#', 'E', 'F', 'G', 'G#', 'A', 'B'], // Level 14: Add G# (9 notes)
                    15: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B'], // Level 15: Add F# (10 notes)
                    16: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B'], // Level 16: Add F# (10 notes)
                    17: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 17: Add A# (11 notes)
                    18: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 18: Add A# (11 notes)
                    19: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 19: Add C# (12 notes - full chromatic)
                    20: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'] // Level 20: Full chromatic
                };

                // Rhythm definitions - simplified
                this.rhythms = {
                    quarter: { taps: 1, symbol: 'â™©', name: 'Quarter' },
                    eighth: { taps: 2, symbol: 'â™«', name: 'Eighth' },
                    triplet: { taps: 3, symbol: 'Â³', name: 'Triplet' },
                    sixteenth: { taps: 4, symbol: 'â™¬', name: 'Sixteenth' }
                };

                // Shepard tone frequencies for one octave
                this.notes = {
                    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
                    'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
                };

                this.initializeAudio();
                this.initializeEventListeners();
                this.updateEnabledRhythms(); // Initialize rhythm settings
                this.updateDisplay();
                this.updateNoteDisplay();

                // Track active oscillators for cleanup
                this.activeOscillators = [];
            }

            async initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.setValueAtTime(0.8, this.audioContext.currentTime); // Increased volume
                } catch (error) {
                    console.error('Error initializing audio:', error);
                    alert('Audio initialization failed. Please try refreshing the page.');
                }
            }

            initializeEventListeners() {
                // Control buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopGame());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('listenAgainBtn').addEventListener('click', () => this.listenAgain());

                // Rhythm toggle controls
                document.getElementById('rhythmQuarter').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmEighth').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmTriplet').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmSixteenth').addEventListener('change', () => this.updateEnabledRhythms());

                // Scale type controls
                document.querySelectorAll('input[name="scaleType"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.usingCustomScale = e.target.value === 'custom';
                        const customContainer = document.getElementById('customScaleContainer');
                        customContainer.style.display = this.usingCustomScale ? 'block' : 'none';
                        this.updateNoteDisplay();
                    });
                });

                // Game mode controls
                document.getElementById('callResponseMode').addEventListener('change', (e) => {
                    this.callResponseMode = e.target.checked;
                    if (this.callResponseMode && this.pitchTrainingMode) {
                        // Can't have both modes active
                        document.getElementById('pitchTrainingMode').checked = false;
                        this.pitchTrainingMode = false;
                    }
                    this.updateDisplay();
                    this.updateControls();
                });

                document.getElementById('pitchTrainingMode').addEventListener('change', (e) => {
                    this.pitchTrainingMode = e.target.checked;
                    if (this.pitchTrainingMode && this.callResponseMode) {
                        // Can't have both modes active
                        document.getElementById('callResponseMode').checked = false;
                        this.callResponseMode = false;
                    }
                    this.pitchTrainingListenCount = 0; // Reset listen count
                    this.updateDisplay();
                    this.updateControls();
                });

                // Custom note controls
                const noteCheckboxes = ['C', 'Csharp', 'D', 'Dsharp', 'E', 'F', 'Fsharp', 'G', 'Gsharp', 'A', 'Asharp', 'B'];
                noteCheckboxes.forEach(note => {
                    const checkbox = document.getElementById(`note${note}`);
                    if (checkbox) {
                        checkbox.addEventListener('change', () => this.updateCustomScale());
                    }
                });

                // Hide custom scale container when clicking outside
                document.addEventListener('click', (e) => {
                    const customContainer = document.getElementById('customScaleContainer');
                    const scaleControls = document.querySelector('.scale-controls');

                    // Check if click is outside the scale controls area and custom container is visible
                    if (this.usingCustomScale &&
                        customContainer &&
                        customContainer.style.display !== 'none' &&
                        !scaleControls.contains(e.target)) {

                        // Just hide the custom container, but keep custom mode active
                        customContainer.style.display = 'none';
                    }
                });

                // Light click events
                document.querySelectorAll('.light').forEach((light, index) => {
                    light.addEventListener('mousedown', (e) => this.onLightPress(index, e));
                    light.addEventListener('mouseup', (e) => this.onLightRelease(index, e));
                    light.addEventListener('mouseleave', (e) => this.onLightRelease(index, e));

                    // Touch events for mobile
                    light.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.onLightPress(index, e);
                    });
                    light.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.onLightRelease(index, e);
                    });
                });
            }

            // Stop all active audio
            stopAllAudio() {
                this.activeOscillators.forEach(osc => {
                    try {
                        if (osc && osc.stop) {
                            osc.stop();
                        }
                    } catch (e) {
                        // Oscillator may already be stopped
                    }
                });
                this.activeOscillators = [];
            }

            // User feedback tone with proper duration matching the rhythm
            playUserFeedbackTone(frequency, rhythmData) {
                if (!this.audioContext) return;

                try {
                    // Calculate the full duration this rhythm should have
                    const beatDuration = (60000 / this.bpm); // Keep in milliseconds
                    let subdivisionDuration = beatDuration / rhythmData.taps;

                    // Set minimum subdivision duration to prevent overlapping
                    const minSubdivisionDuration = 150; // Minimum 150ms between notes
                    if (subdivisionDuration < minSubdivisionDuration) {
                        subdivisionDuration = minSubdivisionDuration;
                    }

                    const noteDuration = (subdivisionDuration * 0.6) / 1000; // Convert to seconds, 60% for note

                    // Create Shepard tone with multiple octaves - same as sequence playback
                    const octaves = [1, 2, 4, 8]; // Four octaves
                    const gains = [0.3, 0.4, 0.4, 0.3]; // Bell curve weighting
                    const currentTime = this.audioContext.currentTime;

                    octaves.forEach((octaveMultiplier, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        // Set frequency for this octave
                        const octaveFreq = frequency * octaveMultiplier;
                        osc.frequency.setValueAtTime(octaveFreq, currentTime);
                        osc.type = 'sine';

                        // Envelope with proper decay length matching the rhythm
                        const maxGain = gains[index] * 0.18; // Slightly louder for user feedback
                        gain.gain.setValueAtTime(0, currentTime);
                        gain.gain.linearRampToValueAtTime(maxGain, currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(maxGain * 0.4, currentTime + noteDuration * 0.5);
                        gain.gain.exponentialRampToValueAtTime(0.001, currentTime + noteDuration);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        // Schedule start and stop
                        osc.start(currentTime);
                        osc.stop(currentTime + noteDuration);

                        // Track for cleanup
                        this.activeOscillators.push(osc);

                        // Remove from tracking when it naturally ends
                        osc.onended = () => {
                            const index = this.activeOscillators.indexOf(osc);
                            if (index > -1) {
                                this.activeOscillators.splice(index, 1);
                            }
                        };
                    });

                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }

            // Shepard tone generator with proper note durations
            playTone(frequency, noteDurationMs) {
                if (!this.audioContext) return;

                try {
                    // Convert milliseconds to seconds
                    const noteDuration = noteDurationMs / 1000;

                    // Create Shepard tone with multiple octaves
                    const octaves = [1, 2, 4, 8]; // Four octaves
                    const gains = [0.3, 0.4, 0.4, 0.3]; // Bell curve weighting
                    const currentTime = this.audioContext.currentTime;

                    octaves.forEach((octaveMultiplier, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        // Set frequency for this octave
                        const octaveFreq = frequency * octaveMultiplier;
                        osc.frequency.setValueAtTime(octaveFreq, currentTime);
                        osc.type = 'sine';

                        // Envelope with decay
                        const maxGain = gains[index] * 0.12; // Reduced volume further
                        gain.gain.setValueAtTime(0, currentTime);
                        gain.gain.linearRampToValueAtTime(maxGain, currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(maxGain * 0.4, currentTime + noteDuration * 0.5);
                        gain.gain.exponentialRampToValueAtTime(0.001, currentTime + noteDuration);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        // Schedule start and stop
                        osc.start(currentTime);
                        osc.stop(currentTime + noteDuration);

                        // Track for cleanup
                        this.activeOscillators.push(osc);

                        // Remove from tracking when it naturally ends
                        osc.onended = () => {
                            const index = this.activeOscillators.indexOf(osc);
                            if (index > -1) {
                                this.activeOscillators.splice(index, 1);
                            }
                        };
                    });

                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }

            // Update enabled rhythms based on checkboxes
            updateEnabledRhythms() {
                this.enabledRhythms = [];
                if (document.getElementById('rhythmQuarter').checked) this.enabledRhythms.push('quarter');
                if (document.getElementById('rhythmEighth').checked) this.enabledRhythms.push('eighth');
                if (document.getElementById('rhythmTriplet').checked) this.enabledRhythms.push('triplet');
                if (document.getElementById('rhythmSixteenth').checked) this.enabledRhythms.push('sixteenth');

                // Ensure at least one rhythm is enabled
                if (this.enabledRhythms.length === 0) {
                    this.enabledRhythms.push('quarter');
                    document.getElementById('rhythmQuarter').checked = true;
                }
            }

            // Update custom scale based on note checkboxes
            updateCustomScale() {
                this.customNotes = [];
                const noteMap = {
                    'C': 'C', 'Csharp': 'C#', 'D': 'D', 'Dsharp': 'D#',
                    'E': 'E', 'F': 'F', 'Fsharp': 'F#', 'G': 'G',
                    'Gsharp': 'G#', 'A': 'A', 'Asharp': 'A#', 'B': 'B'
                };

                Object.keys(noteMap).forEach(checkboxId => {
                    const checkbox = document.getElementById(`note${checkboxId}`);
                    if (checkbox && checkbox.checked) {
                        this.customNotes.push(noteMap[checkboxId]);
                    }
                });

                // Ensure at least one note is selected
                if (this.customNotes.length === 0) {
                    this.customNotes.push('C');
                    document.getElementById('noteC').checked = true;
                }

                this.updateNoteDisplay();
            }

            // Update note display based on available notes
            updateNoteDisplay() {
                const lights = document.querySelectorAll('.light');
                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

                // Reset container styles for linear layout
                const container = document.querySelector('.notes-container');
                container.classList.add('linear-layout');
                container.style.width = 'auto';
                container.style.height = '180px';

                let visibleIndex = 0;
                lights.forEach((light, index) => {
                    const note = chromaticScale[index];
                    light.dataset.note = note;
                    light.querySelector('.light-number').textContent = note;

                    if (availableNotes.includes(note)) {
                        light.style.display = 'flex';
                        light.style.opacity = '1';
                        light.style.pointerEvents = 'auto';

                        // Clear any inline positioning styles
                        light.style.left = '';
                        light.style.top = '';
                        light.style.transform = '';

                        visibleIndex++;
                    } else {
                        light.style.display = 'none';
                    }
                });
            }            // Get available notes for current level
            getAvailableNotesForLevel(level = null) {
                if (this.usingCustomScale) {
                    return this.customNotes;
                }
                // Use current level, not round
                const currentLevel = level || this.currentLevel;
                const clampedLevel = Math.min(currentLevel, 10);
                return this.levelNotes[clampedLevel] || this.levelNotes[10];
            }

            // Generate random sequence item - only from available notes and enabled rhythms
            generateSequenceItem() {
                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

                // Find positions that have available notes
                const availablePositions = [];
                chromaticScale.forEach((note, index) => {
                    if (availableNotes.includes(note)) {
                        availablePositions.push(index);
                    }
                });

                if (availablePositions.length === 0) {
                    // Fallback to position 0 if no notes available
                    availablePositions.push(0);
                }

                let lightIndex;

                // Improved randomization to avoid repetitive patterns
                if (this.lastNoteIndex === -1 || availablePositions.length <= 2) {
                    // First note or very few options - pick randomly
                    lightIndex = availablePositions[Math.floor(Math.random() * availablePositions.length)];
                } else {
                    // Create weighted selection to encourage variety
                    const weights = [];
                    const recentNotes = this.gameSequence.slice(-3).map(item => item.lightIndex); // Last 3 notes

                    for (const pos of availablePositions) {
                        if (pos === this.lastNoteIndex) {
                            // Never repeat the immediate previous note
                            continue;
                        }

                        let weight = 1.0;

                        // Reduce weight if note was used recently (within last 3)
                        const recentCount = recentNotes.filter(recent => recent === pos).length;
                        if (recentCount > 0) {
                            weight = 0.3; // Much lower weight for recently used notes
                        }

                        // Slightly favor notes that haven't been used at all yet
                        const usedInSequence = this.gameSequence.some(item => item.lightIndex === pos);
                        if (!usedInSequence) {
                            weight += 0.5; // Bonus for unused notes
                        }

                        weights.push({ pos, weight });
                    }

                    // If all notes are heavily weighted down, reset to equal weights
                    if (weights.length === 0 || weights.every(w => w.weight < 0.5)) {
                        lightIndex = availablePositions.filter(pos => pos !== this.lastNoteIndex)[0] ||
                            availablePositions[Math.floor(Math.random() * availablePositions.length)];
                    } else {
                        // Weighted random selection
                        const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
                        let random = Math.random() * totalWeight;

                        for (const w of weights) {
                            random -= w.weight;
                            if (random <= 0) {
                                lightIndex = w.pos;
                                break;
                            }
                        }

                        // Fallback if something went wrong
                        if (lightIndex === undefined) {
                            lightIndex = weights[0].pos;
                        }
                    }
                }

                // Store this position for next time
                this.lastNoteIndex = lightIndex;

                // Improved rhythm randomization - favor variety
                const enabledRhythmKeys = this.enabledRhythms;
                let rhythmKey;

                if (this.gameSequence.length === 0) {
                    // First item - any rhythm is fine
                    rhythmKey = enabledRhythmKeys[Math.floor(Math.random() * enabledRhythmKeys.length)];
                } else {
                    // Check last few rhythms to encourage variety
                    const recentRhythms = this.gameSequence.slice(-2).map(item => item.rhythm);
                    const availableRhythms = enabledRhythmKeys.filter(r => !recentRhythms.includes(r));

                    if (availableRhythms.length > 0 && Math.random() < 0.7) {
                        // 70% chance to use a rhythm that wasn't used recently
                        rhythmKey = availableRhythms[Math.floor(Math.random() * availableRhythms.length)];
                    } else {
                        // 30% chance to use any rhythm (allows some repetition)
                        rhythmKey = enabledRhythmKeys[Math.floor(Math.random() * enabledRhythmKeys.length)];
                    }
                }

                const light = document.getElementById(`light-${lightIndex}`);
                const note = light.dataset.note;

                return {
                    lightIndex,
                    note,
                    rhythm: rhythmKey,
                    rhythmData: this.rhythms[rhythmKey]
                };
            }

            // Start new game - faster setup
            async startGame() {
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.gameState = 'playing';
                this.playerSequence = [];
                this.currentRound = 1;
                this.currentLevel = 1; // Reset to level 1
                this.correctInRow = 0; // Reset progression counter
                this.bpm = 50; // Reset BPM to starting value (50 BPM)
                this.lastNoteIndex = -1; // Reset note tracking
                this.lives = 3; // Reset lives to 3

                // Reset game mode specific variables
                if (this.callResponseMode) {
                    this.isPlayer1Turn = true; // Start with Player 1 in call & response
                    this.player1Sequence = [];
                    this.callResponseRound = 1; // Reset to round 1
                } else {
                    this.isPlayer1Turn = false; // Not relevant for other modes
                }

                if (this.pitchTrainingMode) {
                    this.pitchTrainingListenCount = 0; // Reset listen count for pitch training
                }

                // Start with one simple item
                this.gameSequence = [this.generateSequenceItem()];

                // Reset scoring
                this.totalScore = 0;
                this.levelScore = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.currentLevelRhythmBonus = 0; // Reset rhythm bonus for new game
                this.listenAgainUsed = false; // Reset Listen Again for new game

                this.updateDisplay();
                this.updateControls();
                this.updateNoteDisplay(); // Ensure proper note display for level 1

                // Handle different game modes
                if (this.callResponseMode) {
                    // In call & response mode, start with Player 1's turn
                    this.startCallResponseTurn();
                } else {
                    // Normal mode or pitch training - start playing sequence
                    setTimeout(() => {
                        // Play start round sound only if Sound FX is enabled
                        const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                        if (soundFxEnabled) {
                            const startRoundAudio = new Audio('startround.mp3');
                            startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                        }

                        // Show "Get Ready!" modal for 3 seconds, then start sequence
                        this.showGetReadyModal(() => {
                            if (this.pitchTrainingMode) {
                                this.playSequenceWithPitchTraining();
                            } else {
                                this.playSequence();
                            }
                        });
                    }, 300);
                }
            }

            // Start a turn in Call & Response mode
            async startCallResponseTurn() {
                // Ensure audio context is ready to prevent glitches
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                if (this.isPlayer1Turn) {
                    // Player 1's turn - they create the call
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls();

                    // Only show instruction modal for the first round
                    if (this.callResponseRound === 1) {
                        this.showCallResponseInstruction("Player 1: Create your call!", "Start playing notes to create a pattern for Player 2 to copy.");
                    } else {
                        // Directly start Player 1's input for subsequent rounds
                        this.startPlayer1Input();
                    }
                } else {
                    // Player 2's turn - they respond to Player 1's call
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls();

                    // Only show instruction modal for the first round
                    if (this.callResponseRound === 1) {
                        this.showCallResponseInstruction("Player 2: Match the call!", "Copy the pattern that Player 1 just played.");
                    } else {
                        // Directly start Player 2's input for subsequent rounds
                        this.startPlayer2Input();
                    }
                }
            }

            // Show instruction modal for call and response mode
            showCallResponseInstruction(title, message) {
                // Create instruction overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(5px);
                `;

                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                const titleElement = document.createElement('div');
                titleElement.textContent = title;
                titleElement.style.cssText = `
                    font-size: 1.8rem;
                    font-weight: bold;
                    margin-bottom: 15px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                `;

                const messageElement = document.createElement('div');
                messageElement.textContent = message;
                messageElement.style.cssText = `
                    font-size: 1.2rem;
                    margin-bottom: 20px;
                    line-height: 1.4;
                `;

                const readyButton = document.createElement('button');
                readyButton.textContent = 'Ready!';
                readyButton.style.cssText = `
                    background: linear-gradient(45deg, #28a745, #20c997);
                    color: white;
                    border: none;
                    padding: 12px 25px;
                    border-radius: 25px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;

                readyButton.onmouseover = () => {
                    readyButton.style.transform = 'translateY(-2px)';
                    readyButton.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                readyButton.onmouseout = () => {
                    readyButton.style.transform = 'translateY(0)';
                    readyButton.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };

                readyButton.onclick = () => {
                    document.body.removeChild(overlay);
                    // Start the actual turn after instruction is dismissed
                    if (this.isPlayer1Turn) {
                        this.startPlayer1Input();
                    } else {
                        this.startPlayer2Input();
                    }
                };

                // Auto-dismiss after 1.5 seconds
                setTimeout(() => {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        // Start the actual turn after auto-dismiss
                        if (this.isPlayer1Turn) {
                            this.startPlayer1Input();
                        } else {
                            this.startPlayer2Input();
                        }
                    }
                }, 1500);

                modal.appendChild(titleElement);
                modal.appendChild(messageElement);
                modal.appendChild(readyButton);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
            }

            // Start Player 1's input phase
            async startPlayer1Input() {
                // Ensure audio context is ready to prevent glitches
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.player1Sequence = [];
                this.lastPlayer1InputTime = Date.now();

                // Start monitoring for 1.5 seconds of silence to end Player 1's turn
                this.checkPlayer1Silence();
            }

            // Check if Player 1 has been silent for 1.5 seconds
            checkPlayer1Silence() {
                const checkInterval = 100; // Check every 100ms
                const silenceThreshold = 1500; // 1.5 seconds of silence

                this.silenceCheckInterval = setInterval(() => {
                    const now = Date.now();
                    const timeSinceLastInput = now - this.lastPlayer1InputTime;

                    if (this.player1Sequence.length > 0 && timeSinceLastInput >= silenceThreshold) {
                        // Player 1 has been silent for 1.5 seconds and has played at least one note
                        clearInterval(this.silenceCheckInterval);
                        this.endPlayer1Call();
                    }
                }, checkInterval);
            }

            // Start Player 2's input phase
            async startPlayer2Input() {
                // Ensure audio context is ready to prevent glitches
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.playerSequence = [];

                // Set timeout for Player 2's entire response (10 seconds)
                this.callResponseTimeout = setTimeout(() => {
                    this.compareCallResponse();
                }, 10000);
            }

            // Stop game
            stopGame() {
                this.gameState = 'stopped';
                this.stopAllAudio(); // Stop any playing audio
                this.clearAllTimeouts();
                this.clearAllLights();

                // Clear call and response specific timers
                if (this.silenceCheckInterval) {
                    clearInterval(this.silenceCheckInterval);
                    this.silenceCheckInterval = null;
                }
                if (this.callResponseTimeout) {
                    clearTimeout(this.callResponseTimeout);
                    this.callResponseTimeout = null;
                }

                this.updateDisplay();
                this.updateControls();
            }

            // Reset game
            resetGame() {
                this.stopGame();
                this.gameSequence = [];
                this.playerSequence = [];
                this.currentRound = 1;
                this.currentLevel = 1; // Reset to level 1
                this.correctInRow = 0; // Reset progression counter
                this.bpm = 50; // Reset BPM to starting value (50 BPM)
                this.lastNoteIndex = -1; // Reset note tracking
                this.lives = 3; // Reset lives to 3
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.updateDisplay();
                this.updateNoteDisplay(); // Refresh notes for level 1
                this.updateControls(); // Update button states
            }

            // Special sequence playback for pitch training mode - only shows first note visually
            playSequenceWithPitchTraining() {
                this.gameState = 'playing';
                this.updateDisplay();

                let delay = 0;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                this.gameSequence.forEach((item, index) => {
                    setTimeout(() => {
                        if (index === 0) {
                            // Only animate the first note of the entire sequence visually
                            this.playSequenceItem(item, true);
                        } else {
                            // Play audio only for all other notes (no visual animation)
                            this.playSequenceItem(item, false);
                        }
                    }, delay);

                    // Each round takes exactly one beat duration, regardless of subdivisions
                    delay += beatDuration; // No gaps - each round is exactly 1 beat
                });

                // Switch to player turn after sequence completes - no extra delay
                setTimeout(() => {
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls(); // Update button states including Listen Again
                }, delay);
            }

            // Play sequence - each round is exactly 1 beat duration
            playSequence() {
                this.gameState = 'playing';
                this.updateDisplay();

                let delay = 0;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                this.gameSequence.forEach((item, index) => {
                    setTimeout(() => {
                        this.playSequenceItem(item);
                    }, delay);

                    // Each round takes exactly one beat duration, regardless of subdivisions
                    delay += beatDuration; // No gaps - each round is exactly 1 beat
                });

                // Switch to player turn after sequence completes - no extra delay
                setTimeout(() => {
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls(); // Update button states including Listen Again
                }, delay); // Removed the +200ms delay
            }

            // Play individual sequence item - subdivisions within one beat with proper timing
            playSequenceItem(item, visual = true) {
                const light = document.getElementById(`light-${item.lightIndex}`);
                const frequency = this.notes[item.note];
                const tapsToPlay = item.rhythmData.taps;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                // Calculate subdivision timing within the beat
                let subdivisionDuration = beatDuration / tapsToPlay; // Each tap gets equal share of the beat

                // Set minimum subdivision duration to prevent overlapping (especially for 16th notes)
                const minSubdivisionDuration = 150; // Minimum 150ms between notes
                if (subdivisionDuration < minSubdivisionDuration) {
                    subdivisionDuration = minSubdivisionDuration;
                }

                const noteDuration = subdivisionDuration * 0.6; // 60% of subdivision for note (reduced to prevent overlap)
                const gapDuration = subdivisionDuration * 0.4; // 40% gap (increased for cleaner separation)

                // Visual and audio for each subdivision
                for (let i = 0; i < tapsToPlay; i++) {
                    setTimeout(() => {
                        // Visual flash - duration matches note duration (only 'playing' class for sequence)
                        if (visual) {
                            light.classList.add('playing');
                            setTimeout(() => {
                                light.classList.remove('playing');
                            }, noteDuration);
                        }
                        // Audio with Shepard tone and proper duration
                        this.playTone(frequency, noteDuration); // Use noteDuration instead of subdivisionDuration
                    }, i * subdivisionDuration);
                }
            }

            // Play sequence item audio only (no visual animation) - for pitch training mode
            playSequenceItemAudioOnly(item) {
                // Call playSequenceItem with visual = false
                this.playSequenceItem(item, false);
            }

            // Listen Again function - replay current sequence once per level
            listenAgain() {
                if (this.gameState !== 'listening' || !this.isPlayerTurn) {
                    return; // Can't use if not in listening state or not player turn
                }

                if (this.pitchTrainingMode) {
                    // In pitch training mode, allow 2 Listen Again uses
                    if (this.pitchTrainingListenCount >= 2) {
                        return; // Already used both listens
                    }
                    this.pitchTrainingListenCount++;
                } else {
                    // Normal mode - only one use per level
                    if (this.listenAgainUsed) {
                        return; // Already used
                    }
                    this.listenAgainUsed = true;
                }

                // Temporarily disable player turn and replay sequence
                this.isPlayerTurn = false;
                this.gameState = 'playing';
                this.updateDisplay(); // Update display to show remaining listens
                this.updateControls(); // Update button states

                // Replay the current sequence
                if (this.pitchTrainingMode) {
                    this.playSequenceWithPitchTraining();
                } else {
                    this.playSequence();
                }
            }

            // Handle light press - simplified validation with timing tolerance
            onLightPress(lightIndex, event) {
                if (!this.isPlayerTurn) return;

                // Handle different game modes
                if (this.callResponseMode) {
                    this.handleCallResponsePress(lightIndex);
                } else {
                    this.handleNormalGamePress(lightIndex);
                }
            }

            // Handle input for normal game mode (including pitch training)
            handleNormalGamePress(lightIndex) {
                const expectedItem = this.gameSequence[this.currentSequenceIndex];
                if (!expectedItem) return;

                // Check correct light
                if (lightIndex !== expectedItem.lightIndex) {
                    this.loseLife();
                    return;
                }

                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.add('active');

                // PLAY AUDIO FEEDBACK with proper duration matching the expected rhythm
                const note = light.dataset.note;
                const frequency = this.notes[note];
                this.playUserFeedbackTone(frequency, expectedItem.rhythmData);

                // Track timing for validation - start timing from first note press
                if (this.currentTapCount === 0) {
                    this.tapStartTime = Date.now();
                    this.currentItemStartTime = Date.now(); // Track when this item started
                }

                this.currentTapCount++;

                // Check if we've got enough taps
                const requiredTaps = expectedItem.rhythmData.taps;
                if (this.currentTapCount >= requiredTaps) {
                    // Basic validation - ensure correct number of taps
                    if (this.currentTapCount > 1) {
                        const totalTime = Date.now() - this.tapStartTime;
                        const beatDuration = 60000 / this.bpm; // Duration of one beat in ms
                        const expectedTime = (requiredTaps - 1) * (beatDuration / requiredTaps); // Subdivisions within beat

                        // Basic acceptance tolerance (50%) - too slow fails
                        const basicTolerance = expectedTime * 0.5;
                        if (totalTime > expectedTime + basicTolerance) {
                            this.loseLife();
                            return;
                        }
                    }

                    // Success! Move to next item
                    this.playerSequence.push({
                        lightIndex,
                        note: light.dataset.note,
                        rhythm: expectedItem.rhythm,
                        tapCount: this.currentTapCount,
                        startTime: this.currentItemStartTime,
                        endTime: Date.now()
                    });

                    this.currentSequenceIndex++;
                    this.currentTapCount = 0;

                    // Check if sequence complete
                    if (this.currentSequenceIndex >= this.gameSequence.length) {
                        // Calculate rhythm bonus for the ENTIRE sequence timing
                        this.calculateSequenceRhythmBonus();
                        setTimeout(() => this.nextRound(), 500);
                    }
                }

                this.playerPressedLight = lightIndex;
            }

            // Handle input for call and response mode
            handleCallResponsePress(lightIndex) {
                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.add('active');

                // PLAY AUDIO FEEDBACK
                const note = light.dataset.note;
                const frequency = this.notes[note];

                // For call and response, we need to record the actual performance
                if (this.isPlayer1Turn) {
                    // Player 1 is making the call - record everything they do
                    this.recordCallResponseInput(lightIndex, note, true); // true = is Player 1
                } else {
                    // Player 2 is responding - record and compare
                    this.recordCallResponseInput(lightIndex, note, false); // false = is Player 2
                }

                // Play audio feedback (no specific rhythm expected in call/response)
                this.playUserFeedbackTone(frequency, { taps: 1 }); // Single tap feedback

                this.playerPressedLight = lightIndex;
            }

            // Record input for call and response mode
            recordCallResponseInput(lightIndex, note, isPlayer1) {
                const timestamp = Date.now();

                const inputData = {
                    lightIndex,
                    note,
                    timestamp,
                    isPlayer1
                };

                if (isPlayer1) {
                    // Player 1 is creating the call
                    if (this.player1Sequence.length === 0) {
                        // First input - start timing
                        this.callResponseStartTime = timestamp;
                    }
                    this.player1Sequence.push(inputData);

                    // Update the last input time for silence detection
                    this.lastPlayer1InputTime = timestamp;
                } else {
                    // Player 2 is responding
                    if (this.playerSequence.length === 0) {
                        // First response - start timing
                        this.responseStartTime = timestamp;
                    }
                    this.playerSequence.push(inputData);

                    // Check if Player 2 has matched the length of Player 1's sequence
                    if (this.playerSequence.length >= this.player1Sequence.length) {
                        clearTimeout(this.callResponseTimeout);
                        this.compareCallResponse();
                    }
                }
            }

            // End Player 1's call and switch to Player 2
            endPlayer1Call() {
                if (this.player1Sequence.length === 0) {
                    // Player 1 didn't play anything, restart their turn
                    this.showCallResponseInstruction("Player 1: Try again!", "You need to play at least one note to create a call.");
                    return;
                }

                // Clear the silence checking interval
                clearInterval(this.silenceCheckInterval);

                this.isPlayer1Turn = false;
                this.isPlayerTurn = true;
                this.playerSequence = [];
                this.updateDisplay();

                // Show instruction for Player 2, then start their input
                this.showCallResponseInstruction("Player 2: Your turn!", `Match the ${this.player1Sequence.length} note${this.player1Sequence.length > 1 ? 's' : ''} that Player 1 just played.`);
            }

            // Compare Player 2's response to Player 1's call
            compareCallResponse() {
                clearTimeout(this.callResponseTimeout);

                if (this.playerSequence.length === 0) {
                    // Player 2 didn't respond
                    this.callResponseFeedback("Player 2 didn't respond!", false);
                    return;
                }

                // Compare pitch accuracy (100% required)
                let pitchMatch = true;
                let rhythmAccuracy = 0;

                const minLength = Math.min(this.player1Sequence.length, this.playerSequence.length);

                // Check pitch accuracy
                for (let i = 0; i < minLength; i++) {
                    if (this.player1Sequence[i].note !== this.playerSequence[i].note) {
                        pitchMatch = false;
                        break;
                    }
                }

                // Check sequence length
                if (this.player1Sequence.length !== this.playerSequence.length) {
                    pitchMatch = false;
                }

                // Calculate rhythm accuracy (timing comparison)
                if (pitchMatch && this.player1Sequence.length > 1) {
                    const player1Intervals = [];
                    const player2Intervals = [];

                    // Calculate intervals between notes
                    for (let i = 1; i < this.player1Sequence.length; i++) {
                        player1Intervals.push(this.player1Sequence[i].timestamp - this.player1Sequence[i - 1].timestamp);
                    }
                    for (let i = 1; i < this.playerSequence.length; i++) {
                        player2Intervals.push(this.playerSequence[i].timestamp - this.playerSequence[i - 1].timestamp);
                    }

                    // Compare intervals with 75% tolerance
                    let matchingIntervals = 0;
                    for (let i = 0; i < player1Intervals.length; i++) {
                        const expected = player1Intervals[i];
                        const actual = player2Intervals[i];
                        const tolerance = expected * 0.25; // 25% tolerance (so 75% accuracy required)

                        if (Math.abs(actual - expected) <= tolerance) {
                            matchingIntervals++;
                        }
                    }

                    rhythmAccuracy = matchingIntervals / player1Intervals.length;
                } else if (pitchMatch && this.player1Sequence.length === 1) {
                    // Single note - rhythm doesn't matter
                    rhythmAccuracy = 1.0;
                }

                // Determine success
                const success = pitchMatch && rhythmAccuracy >= 0.75;

                // Calculate pitch accuracy stats
                let correctNotes = 0;
                for (let i = 0; i < minLength; i++) {
                    if (this.player1Sequence[i].note === this.playerSequence[i].note) {
                        correctNotes++;
                    }
                }
                const totalNotes = this.player1Sequence.length;
                const pitchPercentage = totalNotes > 0 ? Math.round((correctNotes / totalNotes) * 100) : 0;

                if (success) {
                    // Calculate multipliers for call & response
                    const rhythmMultiplier = this.enabledRhythms.length; // 1-4x based on number of rhythms
                    const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                    const noteMultiplier = Math.max(1, availableNotes.length - 2); // 3 notes = x1, 4 notes = x2, etc.
                    const totalMultiplier = rhythmMultiplier * noteMultiplier;

                    const basePoints = 100;
                    const multipliedPoints = basePoints * totalMultiplier;
                    this.totalScore += multipliedPoints;

                    this.callResponseFeedback(`Excellent! Notes: ${correctNotes}/${totalNotes}, Rhythm: ${Math.round(rhythmAccuracy * 100)}% (+${multipliedPoints} pts)`, true);
                } else if (!pitchMatch) {
                    // Notes are wrong - focus on note feedback
                    this.callResponseFeedback(`Nearly there! Notes: ${correctNotes}/${totalNotes} (${pitchPercentage}%) - try the melody again!`, false);
                } else {
                    // Notes are correct but rhythm is wrong - focus on rhythm feedback  
                    this.callResponseFeedback(`Good notes! Rhythm: ${Math.round(rhythmAccuracy * 100)}% - try matching the timing!`, false);
                }
            }

            // Show feedback for call and response
            callResponseFeedback(message, success) {
                // Create feedback overlay similar to level celebration
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const feedbackText = document.createElement('div');
                feedbackText.textContent = message;
                feedbackText.style.cssText = `
                    color: ${success ? '#4CAF50' : '#F44336'};
                    font-size: 2rem;
                    font-weight: bold;
                    text-align: center;
                    background: white;
                    padding: 30px;
                    border-radius: 20px;
                    border: 3px solid ${success ? '#4CAF50' : '#F44336'};
                `;

                overlay.appendChild(feedbackText);
                document.body.appendChild(overlay);

                // Remove after 3 seconds and start new round
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    this.startNewCallResponseRound();
                }, 3000);
            }

            // Start a new round in call and response mode
            startNewCallResponseRound() {
                this.currentRound++;
                this.callResponseRound++; // Increment call & response round
                this.isPlayer1Turn = true;
                this.player1Sequence = [];
                this.playerSequence = [];
                this.updateDisplay();
                this.startCallResponseTurn();
            }

            // Handle light release - No beeping
            onLightRelease(lightIndex, event) {
                if (!this.isPlayerTurn || this.playerPressedLight !== lightIndex) return;

                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.remove('active');

                this.playerPressedLight = null;
            }

            // Calculate rhythm bonus for the entire sequence timing
            calculateSequenceRhythmBonus() {
                if (this.playerSequence.length < 2) {
                    // Single note sequences don't get rhythm bonus
                    return;
                }

                // Calculate expected timing for the entire sequence: (n-1) beats total
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms
                const expectedTotalTime = (this.gameSequence.length - 1) * beatDuration;

                // Get actual timing from player sequence
                const firstItemTime = this.playerSequence[0].startTime || Date.now();
                const lastItemTime = this.playerSequence[this.playerSequence.length - 1].endTime || Date.now();
                const actualTotalTime = lastItemTime - firstItemTime;

                // Check overall sequence timing first - much stricter validation
                let overallTimingAccuracy = 0;
                if (expectedTotalTime > 0) {
                    // Calculate how far off the player was from perfect timing
                    const timingError = Math.abs(actualTotalTime - expectedTotalTime);
                    const maxAllowedError = expectedTotalTime * 0.15; // Only 15% tolerance for timing

                    if (timingError <= maxAllowedError) {
                        // Within acceptable range - calculate accuracy
                        overallTimingAccuracy = 1 - (timingError / maxAllowedError);
                    } else {
                        // Too far off - no accuracy bonus
                        overallTimingAccuracy = 0;
                    }
                }

                // Now check individual rhythm accuracy for each note
                let rhythmAccuracyCount = 0;
                let totalRhythmChecks = 0;

                for (let i = 0; i < this.playerSequence.length; i++) {
                    const playerItem = this.playerSequence[i];
                    const expectedItem = this.gameSequence[i];

                    // Skip rhythm check for quarter notes (single tap)
                    if (expectedItem.rhythmData.taps === 1) {
                        rhythmAccuracyCount++; // Quarter notes are always "accurate"
                        totalRhythmChecks++;
                        continue;
                    }

                    // For multi-tap rhythms, check if player timing matches expected subdivisions
                    const expectedSubdivisionTime = beatDuration / expectedItem.rhythmData.taps;

                    // Calculate player's rhythm timing for this note
                    const playerRhythmTime = playerItem.endTime - playerItem.startTime;
                    const expectedRhythmTime = (expectedItem.rhythmData.taps - 1) * expectedSubdivisionTime;

                    // Much stricter rhythm timing - only 10% tolerance for multi-tap rhythms
                    const rhythmTolerance = expectedRhythmTime * 0.1;
                    if (Math.abs(playerRhythmTime - expectedRhythmTime) <= rhythmTolerance) {
                        rhythmAccuracyCount++;
                    }
                    totalRhythmChecks++;
                }

                // Calculate final rhythm accuracy percentage
                const rhythmAccuracy = totalRhythmChecks > 0 ? rhythmAccuracyCount / totalRhythmChecks : 1;

                // Combine overall timing and rhythm accuracy (both must be good)
                const finalAccuracy = Math.min(overallTimingAccuracy, rhythmAccuracy);

                console.log(`Overall Timing: ${(overallTimingAccuracy * 100).toFixed(1)}%, Rhythm Accuracy: ${(rhythmAccuracy * 100).toFixed(1)}%, Final: ${(finalAccuracy * 100).toFixed(1)}%`);
                console.log(`Expected Total: ${expectedTotalTime}ms, Actual Total: ${actualTotalTime}ms`);

                // Award rhythm bonus based on combined accuracy - much stricter thresholds
                let rhythmBonus = 0;
                if (this.currentLevelRhythmBonus < 250) {
                    if (finalAccuracy >= 0.95) {
                        // Within 95% = 250 bonus (was 90%)
                        rhythmBonus = Math.min(250, 250 - this.currentLevelRhythmBonus);
                        this.perfectTimingCount++;
                    } else if (finalAccuracy >= 0.85) {
                        // Within 85% = 100 bonus (was 75%)
                        rhythmBonus = Math.min(100, 250 - this.currentLevelRhythmBonus);
                    } else if (finalAccuracy >= 0.7) {
                        // Within 70% = 50 bonus (was 50%)
                        rhythmBonus = Math.min(50, 250 - this.currentLevelRhythmBonus);
                    }
                }

                // Store bonus but DON'T add to total score yet - only add to level tracking
                if (rhythmBonus > 0) {
                    this.levelScore += rhythmBonus; // Track for level display only
                    this.currentLevelRhythmBonus += rhythmBonus; // Track rhythm bonus for this level
                    // DON'T add to totalScore here - only at end of level
                }

                this.totalTimingAttempts++;
            }

            // Detect rhythm based on duration
            detectRhythm(beats) {
                const rhythmEntries = Object.entries(this.rhythms);
                let closestRhythm = 'quarter';
                let smallestDiff = Infinity;

                // Don't auto-detect triplets, they're handled separately
                rhythmEntries.forEach(([key, data]) => {
                    if (key === 'triplet') return;
                    const diff = Math.abs(beats - data.beats);
                    if (diff < smallestDiff) {
                        smallestDiff = diff;
                        closestRhythm = key;
                    }
                });

                return closestRhythm;
            }

            // Advance to next round - Level progression based on sequence length
            nextRound() {
                // Check if we should advance to next level (based on sequence length)
                const targetSequenceLength = this.levelRequirements[this.currentLevel];
                if (this.gameSequence.length >= targetSequenceLength && this.currentLevel < 20) {
                    const newLevel = this.currentLevel + 1;
                    this.currentLevel = newLevel;
                    this.correctInRow = 0; // Reset counter for new level
                    this.bpm = Math.min(50 + (newLevel - 1) * 2, 85); // 2 BPM per level, max 85
                    this.lastNoteIndex = -1; // Reset note tracking for new level
                    this.listenAgainUsed = false; // Reset Listen Again for new level

                    // Show level completion celebration
                    this.showLevelCelebration(newLevel);
                    return; // Exit early, celebration will continue the game
                } else {
                    // Same level, continue building sequence
                    this.currentRound++;
                    // Add ONE new item to the existing sequence (Simon Says behavior)
                    this.gameSequence.push(this.generateSequenceItem());
                }

                // Reset player sequence for the new round
                this.playerSequence = [];
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.isPlayerTurn = false;

                this.updateDisplay();

                // Reduced pause before playing the ENTIRE sequence again
                setTimeout(() => {
                    if (this.pitchTrainingMode) {
                        this.playSequenceWithPitchTraining();
                    } else {
                        this.playSequence();
                    }
                }, 800); // Reduced from 1500ms to 800ms
            }

            // Lose a life - restart the same level
            loseLife() {
                this.lives--;
                this.updateDisplay();

                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Show "Try Again" modal and replay sequence
                    this.showTryAgainModal();
                }
            }

            // Game over
            gameOver() {
                this.gameState = 'stopped';
                this.isPlayerTurn = false;
                this.correctInRow = 0; // Reset on game over
                this.lives = 3; // Reset lives for next game
                // No metronome to stop
                this.updateDisplay();
                this.updateControls();

                this.showGameOverModal();
            }

            // Show "Get Ready!" modal for 3 seconds then start sequence
            showGetReadyModal(callback) {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(5px);
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                    border-radius: 20px;
                    padding: 40px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 300px;
                    width: 90%;
                `;

                // "Get Ready!" title
                const title = document.createElement('div');
                title.textContent = 'Get Ready!';
                title.style.cssText = `
                    font-size: 2.5rem;
                    font-weight: bold;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                    animation: pulse 1s ease-in-out infinite alternate;
                `;

                // Add pulse animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes pulse {
                        from { transform: scale(1); }
                        to { transform: scale(1.05); }
                    }
                `;
                document.head.appendChild(style);

                modal.appendChild(title);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Remove modal after 3 seconds and call the callback
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);
                    if (callback) callback();
                }, 3000);
            }

            showGameOverModal() {
                // Play fail sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const failAudio = new Audio('fail.mp3');
                    failAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                // Game Over title
                const title = document.createElement('div');
                title.textContent = 'GAME OVER';
                title.style.cssText = `
                    font-size: 2.5rem;
                    font-weight: bold;
                    margin-bottom: 20px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                `;

                // Score breakdown
                const scoreBreakdown = document.createElement('div');
                scoreBreakdown.style.cssText = `
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 15px;
                    padding: 20px;
                    margin-bottom: 25px;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                `;

                const finalRound = document.createElement('div');
                finalRound.textContent = `Final Round: ${this.currentRound}`;
                finalRound.style.cssText = `
                    font-size: 1.2rem;
                    margin-bottom: 8px;
                    font-weight: bold;
                `;

                const finalLevel = document.createElement('div');
                finalLevel.textContent = `Final Level: ${this.currentLevel}`;
                finalLevel.style.cssText = `
                    font-size: 1.2rem;
                    margin-bottom: 8px;
                    font-weight: bold;
                `;

                const finalScore = document.createElement('div');
                finalScore.textContent = `Total Score: ${this.score}`;
                finalScore.style.cssText = `
                    font-size: 1.4rem;
                    font-weight: bold;
                    color: #ffeb3b;
                    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
                `;

                scoreBreakdown.appendChild(finalRound);
                scoreBreakdown.appendChild(finalLevel);
                scoreBreakdown.appendChild(finalScore);

                // Button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                    flex-wrap: wrap;
                `;

                // Start Again button (reset to level 1)
                const startAgainBtn = document.createElement('button');
                startAgainBtn.textContent = 'Start Again';
                startAgainBtn.style.cssText = `
                    background: linear-gradient(45deg, #28a745, #20c997);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                startAgainBtn.onmouseover = () => {
                    startAgainBtn.style.transform = 'translateY(-2px)';
                    startAgainBtn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                startAgainBtn.onmouseout = () => {
                    startAgainBtn.style.transform = 'translateY(0)';
                    startAgainBtn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };
                startAgainBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    this.currentLevel = 1;
                    this.currentRound = 1;
                    this.score = 0;
                    this.lives = 3;
                    this.correctInRow = 0;
                    this.sequence = [];
                    this.playerSequence = [];
                    this.gameState = 'stopped';
                    this.updateDisplay();
                    this.updateControls();
                    this.updateNoteDisplay();
                };

                // Continue button (same level, reset score)
                const continueBtn = document.createElement('button');
                continueBtn.textContent = 'Continue';
                continueBtn.style.cssText = `
                    background: linear-gradient(45deg, #007bff, #6f42c1);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                continueBtn.onmouseover = () => {
                    continueBtn.style.transform = 'translateY(-2px)';
                    continueBtn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                continueBtn.onmouseout = () => {
                    continueBtn.style.transform = 'translateY(0)';
                    continueBtn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };
                continueBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    this.currentRound = 1;
                    this.score = 0;
                    this.lives = 3;
                    this.correctInRow = 0;
                    this.sequence = [];
                    this.playerSequence = [];
                    this.gameState = 'stopped';
                    this.updateDisplay();
                    this.updateControls();
                    this.updateNoteDisplay();
                };

                // Quit button
                const quitBtn = document.createElement('button');
                quitBtn.textContent = 'Quit';
                quitBtn.style.cssText = `
                    background: linear-gradient(45deg, #dc3545, #c82333);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                quitBtn.onmouseover = () => {
                    quitBtn.style.transform = 'translateY(-2px)';
                    quitBtn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                quitBtn.onmouseout = () => {
                    quitBtn.style.transform = 'translateY(0)';
                    quitBtn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };
                quitBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    // Just close modal, leave game state as stopped
                };

                buttonContainer.appendChild(startAgainBtn);
                buttonContainer.appendChild(continueBtn);
                buttonContainer.appendChild(quitBtn);

                modal.appendChild(title);
                modal.appendChild(scoreBreakdown);
                modal.appendChild(buttonContainer);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
            }

            // Start a new round with a fresh sequence for the current level
            startRound() {
                // Play start round sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const startRoundAudio = new Audio('startround.mp3');
                    startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Generate a new single-item sequence for the current level
                this.gameSequence = [this.generateSequenceItem()];
                this.playerSequence = [];
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.isPlayerTurn = false;

                this.updateDisplay();
                this.updateNoteDisplay();

                // Start playing the sequence
                setTimeout(() => {
                    // Play start round sound only if Sound FX is enabled
                    const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                    if (soundFxEnabled) {
                        const startRoundAudio = new Audio('startround.mp3');
                        startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                    }

                    // Show "Get Ready!" modal for 3 seconds, then start sequence
                    this.showGetReadyModal(() => {
                        if (this.pitchTrainingMode) {
                            this.playSequenceWithPitchTraining();
                        } else {
                            this.playSequence();
                        }
                    });
                }, 300);
            }

            // Update display elements
            updateDisplay() {
                document.getElementById('totalScore').textContent = this.totalScore.toLocaleString();

                if (this.callResponseMode) {
                    // Show current player with their role in Call & Response mode
                    if (this.isPlayer1Turn) {
                        document.getElementById('round').textContent = 'Player 1 - Call';
                    } else {
                        document.getElementById('round').textContent = 'Player 2 - Response';
                    }
                } else {
                    document.getElementById('round').textContent = this.currentRound;
                }

                if (this.pitchTrainingMode) {
                    // Show remaining Listen Again uses in Pitch Training mode
                    const remainingListens = 2 - this.pitchTrainingListenCount;
                    document.getElementById('lives').textContent = `Listens: ${remainingListens}`;
                } else {
                    document.getElementById('lives').textContent = this.lives;
                }

                // Keep the footer simple and fun for kids - no complex info!
            }

            // Level completion celebration with sound and visual effects
            showLevelCelebration(newLevel) {
                // Calculate score multipliers
                const rhythmMultiplier = this.enabledRhythms.length; // 1-4x based on number of rhythms

                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                const noteMultiplier = Math.max(1, availableNotes.length - 2); // 3 notes = x1, 4 notes = x2, etc.

                let pitchTrainingMultiplier = 1;
                if (this.pitchTrainingMode) {
                    pitchTrainingMultiplier = this.gameSequence.length; // x number of notes in sequence
                }

                // Calculate level scores
                const baseScore = 100; // 100 points for completing level
                const noteBonus = this.gameSequence.length * 50; // 50 points per note
                // rhythmBonus is already added to levelScore in calculateSequenceRhythmBonus

                // Base level score without rhythm bonus
                const baseLevelScore = baseScore + noteBonus;
                const rhythmBonus = this.currentLevelRhythmBonus; // Use the tracked rhythm bonus for this level

                // Apply all multipliers
                const totalMultiplier = rhythmMultiplier * noteMultiplier * pitchTrainingMultiplier;
                this.levelScore = (baseLevelScore + rhythmBonus) * totalMultiplier;
                this.totalScore += this.levelScore; // Add ENTIRE level score to total at end of level

                // Play kids cheering sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const cheeringAudio = new Audio('kids-cheering-sound-effect.mp3');
                    cheeringAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Create celebration overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    font-family: 'Comic Sans MS', 'Trebuchet MS', 'Lucida Grande', Arial, sans-serif;
                `;

                // Level title
                const celebrationText = document.createElement('div');
                celebrationText.textContent = `LEVEL ${newLevel}!`;
                celebrationText.style.cssText = `
                    font-size: 72px;
                    font-weight: 900;
                    color: white;
                    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
                    text-align: center;
                    animation: colorCycle 0.5s ease-in-out infinite alternate;
                    margin-bottom: 30px;
                `;

                // Score breakdown container
                const scoreContainer = document.createElement('div');
                scoreContainer.style.cssText = `
                    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
                    background-size: 400% 400%;
                    padding: 30px;
                    border-radius: 20px;
                    border: 4px solid white;
                    text-align: center;
                    animation: gradientShift 2s ease infinite;
                    min-width: 400px;
                `;

                // Individual score lines
                const baseScoreBeforeMultiplier = baseLevelScore + rhythmBonus;
                const scoreLines = [
                    { text: `Level Complete: +${baseScore}`, delay: 200 },
                    { text: `${this.gameSequence.length} Notes: +${noteBonus}`, delay: 600 },
                    rhythmBonus > 0 ? { text: `Rhythm Accuracy Bonus: +${rhythmBonus}`, delay: 1000 } : null,
                    { text: `Base Score: ${baseScoreBeforeMultiplier}`, delay: rhythmBonus > 0 ? 1200 : 1000 },
                    { text: `${this.enabledRhythms.length} Rhythms: x${rhythmMultiplier}`, delay: rhythmBonus > 0 ? 1400 : 1200, isMultiplier: true },
                    { text: `${availableNotes.length} Notes: x${noteMultiplier}`, delay: rhythmBonus > 0 ? 1600 : 1400, isMultiplier: true },
                    this.pitchTrainingMode ? { text: `Pitch Training: x${pitchTrainingMultiplier}`, delay: rhythmBonus > 0 ? 1800 : 1600, isMultiplier: true } : null,
                    { text: `Final Multiplier: x${totalMultiplier}`, delay: rhythmBonus > 0 ? 2000 : 1800, isMultiplier: true, isFinalMultiplier: true },
                    { text: `Level Total: ${this.levelScore}`, delay: rhythmBonus > 0 ? 2200 : 2000, isTotal: true },
                    { text: `Grand Total: ${this.totalScore.toLocaleString()}`, delay: rhythmBonus > 0 ? 2400 : 2200, isGrandTotal: true }
                ].filter(Boolean);

                scoreLines.forEach((scoreData, index) => {
                    const scoreLine = document.createElement('div');
                    scoreLine.style.cssText = `
                        font-size: ${scoreData.isGrandTotal ? '36px' : scoreData.isTotal ? '28px' : scoreData.isFinalMultiplier ? '26px' : scoreData.isMultiplier ? '22px' : '24px'};
                        font-weight: 900;
                        color: ${scoreData.isGrandTotal ? '#ff1744' : scoreData.isTotal ? '#00e676' : scoreData.isFinalMultiplier ? '#ffd700' : scoreData.isMultiplier ? '#ff9800' : 'white'};
                        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                        margin: 8px 0;
                        opacity: 0;
                        transform: translateY(20px);
                        animation: scoreReveal 0.5s ease forwards;
                        animation-delay: ${scoreData.delay}ms;
                        ${scoreData.isGrandTotal ? 'border-top: 3px solid white; padding-top: 15px; margin-top: 20px;' : ''}
                        ${scoreData.isFinalMultiplier ? 'border-top: 2px solid #ffd700; padding-top: 10px; margin-top: 15px;' : ''}
                    `;
                    scoreLine.textContent = scoreData.text;
                    scoreContainer.appendChild(scoreLine);
                });

                // Add rainbow color cycling animation and score reveal animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes colorCycle {
                        0% { color: #ff0000; }
                        16.67% { color: #ff8000; }
                        33.33% { color: #ffff00; }
                        50% { color: #00ff00; }
                        66.67% { color: #0080ff; }
                        83.33% { color: #8000ff; }
                        100% { color: #ff0080; }
                    }
                    @keyframes gradientShift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }
                    @keyframes scoreReveal {
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }
                `;
                document.head.appendChild(style);

                overlay.appendChild(celebrationText);
                overlay.appendChild(scoreContainer);
                document.body.appendChild(overlay);

                // Remove celebration after 3.5 seconds and continue game
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);

                    // Reset level scoring for next level
                    this.levelScore = 0;
                    this.perfectTimingCount = 0;
                    this.totalTimingAttempts = 0;
                    this.currentLevelRhythmBonus = 0; // Reset rhythm bonus for new level
                    this.listenAgainUsed = false; // Reset Listen Again for new level

                    // Continue with level progression
                    this.gameSequence = [this.generateSequenceItem()];
                    this.currentRound = 1; // Reset round counter for new level
                    this.updateNoteDisplay(); // Update available notes for new level
                    this.updateDisplay();

                    // Start the new level's sequence after a brief pause
                    setTimeout(() => {
                        // Play start round sound only if Sound FX is enabled
                        const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                        if (soundFxEnabled) {
                            const startRoundAudio = new Audio('startround.mp3');
                            startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                        }

                        // Show "Get Ready!" modal for 3 seconds, then start sequence
                        this.showGetReadyModal(() => {
                            if (this.pitchTrainingMode) {
                                this.playSequenceWithPitchTraining();
                            } else {
                                this.playSequence();
                            }
                        });
                    }, 500);
                }, 3500);
            }            // Show "Try Again" modal and replay sequence until correct
            showTryAgainModal() {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    font-family: 'Comic Sans MS', 'Trebuchet MS', 'Lucida Grande', Arial, sans-serif;
                `;

                const modalText = document.createElement('div');
                modalText.textContent = 'Try Again';
                modalText.style.cssText = `
                    font-size: 48px;
                    font-weight: 900;
                    color: #ff6b6b;
                    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
                    text-align: center;
                    background: white;
                    padding: 40px 60px;
                    border-radius: 20px;
                    border: 4px solid #ff6b6b;
                `;

                overlay.appendChild(modalText);
                document.body.appendChild(overlay);

                // Remove modal after 1.5 seconds and replay sequence
                setTimeout(() => {
                    document.body.removeChild(overlay);

                    // Reset player input position but keep same sequence
                    this.playerIndex = 0;
                    this.isPlayerTurn = false;
                    this.gameState = 'playing';

                    // Replay the same sequence after brief pause
                    setTimeout(() => {
                        if (this.pitchTrainingMode) {
                            this.playSequenceWithPitchTraining();
                        } else {
                            this.playSequence();
                        }
                    }, 500);
                }, 1500);
            }

            // Update control buttons
            updateControls() {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const listenAgainBtn = document.getElementById('listenAgainBtn');
                const scaleRadios = document.querySelectorAll('input[name="scaleType"]');

                if (this.gameState === 'stopped') {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    listenAgainBtn.disabled = true;
                    // Enable scale selection when game is stopped
                    scaleRadios.forEach(radio => radio.disabled = false);
                } else {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;

                    // Listen Again button logic depends on game mode
                    if (this.callResponseMode) {
                        // No Listen Again in call & response mode
                        listenAgainBtn.disabled = true;
                    } else if (this.pitchTrainingMode) {
                        // In pitch training, allow 2 Listen Again uses
                        listenAgainBtn.disabled = !(this.gameState === 'listening' && this.isPlayerTurn && this.pitchTrainingListenCount < 2);
                    } else {
                        // Normal mode - enabled only during listening state, not used yet this level
                        listenAgainBtn.disabled = !(this.gameState === 'listening' && this.isPlayerTurn && !this.listenAgainUsed);
                    }

                    // Disable scale selection during active game
                    scaleRadios.forEach(radio => radio.disabled = true);
                }
            }

            // Clear all timeouts
            clearAllTimeouts() {
                if (this.sequenceTimeout) {
                    clearTimeout(this.sequenceTimeout);
                    this.sequenceTimeout = null;
                }
                if (this.playerTimeout) {
                    clearTimeout(this.playerTimeout);
                    this.playerTimeout = null;
                }
            }

            // Clear all light effects
            clearAllLights() {
                document.querySelectorAll('.light').forEach(light => {
                    light.classList.remove('active', 'playing');
                });
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new MemoryRhythmGame();
        });
    </script>
</body>

</html>