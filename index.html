<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy-Cat</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="game-container">
        <header class="game-header">
            <img src="Copycat logo.png" alt="Copy-Cat"
                style="max-height: 120px; max-width: 100%; object-fit: contain; margin-bottom: 20px; filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.3));">

            <!-- Player name display -->
            <div id="playerNameDisplay"
                style="text-align: center; margin: 10px 0; font-size: 1.2rem; font-weight: bold; color: #6c5ce7; display: none; cursor: pointer; transition: all 0.2s; padding: 5px 10px; border-radius: 15px;"
                onmouseover="this.style.backgroundColor='rgba(108, 92, 231, 0.1)'; this.style.transform='scale(1.05)'"
                onmouseout="this.style.backgroundColor='transparent'; this.style.transform='scale(1)'"
                title="Click to view your progress and statistics">
                ‚≠ê <span id="currentPlayerName"></span>
            </div>

            <!-- PRE-GAME UI (shown when game is stopped) -->
            <div id="preGameUI">
                <!-- Main controls for starting the game -->
                <div class="controls">
                    <button id="startBtn" class="btn primary">üéÆ Start Game</button>
                    <button id="optionsBtn" class="btn special">‚öôÔ∏è Options</button>
                    <button id="helpBtn" class="btn info">‚ùì Help</button>
                </div>

                <!-- Options indicator - pre-game -->
                <div class="options-indicator" id="optionsIndicator">
                    <div class="option-tag rhythm-tag">Rhythms: ‚ô©</div>
                    <div class="option-tag note-tag">Notes: üòé Fun Levels</div>
                    <div class="option-tag sound-tag">üîä Sound FX</div>
                </div>

                <!-- My Own Notes checkbox - pre-game only -->
                <div style="text-align: center; margin: 10px 0;">
                    <label id="myOwnNotesCheckboxContainer"
                        style="display: inline-flex; align-items: center; background: rgba(255,255,255,0.95); color: #2d3436; padding: 8px 15px; border-radius: 12px; cursor: pointer; font-size: 1rem; border: 2px solid #ddd; transition: all 0.2s; font-weight: 500;">
                        <input type="checkbox" id="useMyOwnNotesGlobal"
                            style="margin-right: 8px; transform: scale(1.2);">
                        <span>üé® Use My Own Notes</span>
                    </label>
                </div>
            </div>

            <!-- IN-GAME UI (shown when game is running) -->
            <div id="inGameUI" style="display: none;">
                <!-- Game info display -->
                <div class="game-info">
                    <div class="score">Score: <span id="totalScore">0</span></div>
                    <div class="score">Level: <span id="currentLevel">1</span>-<span id="round">1</span></div>
                    <div class="score">Lives: <span id="lives">3</span></div>
                </div>

                <!-- In-game options indicator - minimal -->
                <div class="options-indicator in-game">
                    <div class="option-tag rhythm-tag">Rhythms: ‚ô©</div>
                    <div class="option-tag sound-tag">üîä Sound FX</div>
                </div>

                <!-- In-game controls -->
                <div class="controls">
                    <button id="stopResetBtn" class="btn secondary">üõë Stop/Reset</button>
                    <button id="listenAgainBtn" class="btn special" disabled>üëÇ Listen Again</button>
                </div>
            </div>

            <!-- Hidden options (moved to modal) -->
            <div class="rhythm-controls" style="display: none;">
                <h4>üéµ Rhythm Options:</h4>
                <div class="rhythm-toggles">
                    <label><input type="checkbox" id="rhythmQuarter" checked> ‚ô© - ¬π‚ÅÑ‚ÇÑ notes (üü£ PLUM) </label>
                    <label><input type="checkbox" id="rhythmEighth"> ‚ô´ - ¬π‚ÅÑ‚Çà notes (üçéAPPLE) </label>
                </div>
                <div class="rhythm-toggles" style="margin-top: 10px;">
                    <label><input type="checkbox" id="rhythmTriplet"> ¬≥ - Triplets (üççPINEAPPLE) </label>
                    <label><input type="checkbox" id="rhythmSixteenth"> ‚ô¨ - ¬π‚ÅÑ‚ÇÅ‚ÇÜ notes (üçâWATERMELON) </label>
                </div>
            </div>
            <div class="scale-controls" style="display: none;">
                <h4>üéπ Note Options:</h4>
                <div class="scale-options">
                    <label><input type="radio" name="scaleType" value="progressive" checked> üòé Fun Levels</label>
                    <label><input type="radio" name="scaleType" value="custom"> üé® My Own Notes</label>
                    <label><input type="checkbox" id="muteCheeringSound" checked> üîä Sound FX</label>
                </div>
                <div class="game-mode-options" style="margin-top: 10px;">
                    <button class="game-mode-toggle" id="gameModeToggle">ÔøΩ Normal Mode</button>
                </div>
                <div class="custom-scale" id="customScaleContainer" style="display: none;">
                    <div class="note-toggles">
                        <label><input type="checkbox" id="noteC" checked> C</label>
                        <label><input type="checkbox" id="noteCsharp"> C#</label>
                        <label><input type="checkbox" id="noteD"> D</label>
                        <label><input type="checkbox" id="noteDsharp"> D#</label>
                        <label><input type="checkbox" id="noteE" checked> E</label>
                        <label><input type="checkbox" id="noteF"> F</label>
                        <label><input type="checkbox" id="noteFsharp"> F#</label>
                        <label><input type="checkbox" id="noteG" checked> G</label>
                        <label><input type="checkbox" id="noteGsharp"> G#</label>
                        <label><input type="checkbox" id="noteA"> A</label>
                        <label><input type="checkbox" id="noteAsharp"> A#</label>
                        <label><input type="checkbox" id="noteB"> B</label>
                    </div>
                </div>
            </div>
        </header>

        <main class="game-board">
            <div class="notes-container">
                <!-- 12 Colored lights for chromatic scale notes -->
                <div class="light" id="light-0" data-note="C">
                    <span class="light-number">C</span>
                </div>
                <div class="light" id="light-1" data-note="C#">
                    <span class="light-number">C#</span>
                </div>
                <div class="light" id="light-2" data-note="D">
                    <span class="light-number">D</span>
                </div>
                <div class="light" id="light-3" data-note="D#">
                    <span class="light-number">D#</span>
                </div>
                <div class="light" id="light-4" data-note="E">
                    <span class="light-number">E</span>
                </div>
                <div class="light" id="light-5" data-note="F">
                    <span class="light-number">F</span>
                </div>
                <div class="light" id="light-6" data-note="F#">
                    <span class="light-number">F#</span>
                </div>
                <div class="light" id="light-7" data-note="G">
                    <span class="light-number">G</span>
                </div>
                <div class="light" id="light-8" data-note="G#">
                    <span class="light-number">G#</span>
                </div>
                <div class="light" id="light-9" data-note="A">
                    <span class="light-number">A</span>
                </div>
                <div class="light" id="light-10" data-note="A#">
                    <span class="light-number">A#</span>
                </div>
                <div class="light" id="light-11" data-note="B">
                    <span class="light-number">B</span>
                </div>
            </div>
        </main>
    </div>

    <script>// Memory Rhythm Game - Main JavaScript File

        class MemoryRhythmGame {
            constructor() {
                // Player management
                this.playerName = '';
                this.player2Name = ''; // For 2-player mode
                this.playerStats = {
                    totalGamesPlayed: 0,
                    bestLevel: 1,
                    bestScore: 0,
                    rhythmAccuracyHistory: [],
                    pitchAccuracyHistory: [],
                    sessionScores: []
                };
                this.gameStarted = false; // Track if welcome flow is complete

                this.audioContext = null;
                this.masterGain = null;
                this.gameSequence = [];
                this.playerSequence = [];
                this.currentRound = 1;
                this.gameState = 'stopped'; // 'stopped', 'playing', 'listening', 'waiting'
                this.bpm = 50; // Start at 50 BPM, increases by 2 per level, max 85
                this.sequenceTimeout = null;
                this.playerTimeout = null;
                this.isPlayerTurn = false;
                this.currentSequenceIndex = 0; // Track which item in sequence player is on
                this.currentTapCount = 0; // Track taps for current item
                this.tapStartTime = 0; // Track when player started tapping current item
                this.currentItemStartTime = 0; // Track when current sequence item started
                this.currentItemTapTimes = []; // Track individual tap times for current item
                this.usingCustomScale = false; // Track if using custom scale
                this.customNotes = ['C', 'E', 'G']; // Default custom scale
                this.customNoteSelectionMode = false; // Track if in interactive note selection mode
                this.enabledRhythms = ['quarter', 'eighth']; // Start with quarters and eighths for testing
                this.currentLevel = 1; // Current level (affects available notes)
                this.correctInRow = 0; // Track consecutive correct answers
                this.lastNoteIndex = -1; // Track last note to avoid repetition
                this.lives = 3; // Start with 3 lives

                // Game mode settings
                this.gameMode = 'normal'; // 'normal', 'pitch-training', 'call-response', 'both'
                this.callResponseMode = false; // 2-player call and response mode
                this.pitchTrainingMode = false; // Pitch training mode
                this.isPlayer1Turn = true; // Track whose turn in call and response
                this.player1Sequence = []; // Store player 1's performance for comparison
                this.pitchTrainingListenCount = 0; // Track Listen Again uses in pitch training
                this.callResponseRound = 1; // Track round number for call & response mode

                // Listen Again bonus system
                this.normalListenAgainCount = 1; // Normal mode gets 1 Listen Again per level
                this.bonusListenAgainAwarded = false; // Track if bonus was awarded this level

                // Quick access rhythm cycling system
                this.rhythmCombinations = [
                    ['quarter'],
                    ['eighth'],
                    ['triplet'],
                    ['sixteenth'],
                    ['quarter', 'eighth'],
                    ['quarter', 'sixteenth'],
                    ['eighth', 'sixteenth'],
                    ['sixteenth', 'triplet'],
                    ['quarter', 'eighth', 'sixteenth'],
                    ['eighth', 'triplet', 'sixteenth'],
                    ['quarter', 'eighth', 'triplet'],
                    ['quarter', 'eighth', 'triplet', 'sixteenth']
                ];
                this.currentRhythmComboIndex = 0; // Start with just quarter notes

                // Note cycling system for quick access
                this.noteOptions = [
                    'progression', // Fun Levels progression
                    'custom'       // Custom notes
                ];
                this.currentNoteOptionIndex = 0; // Start with progression

                // Scoring system
                this.totalScore = 0;
                this.levelScore = 0;
                this.rhythmAccuracy = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.sessionRhythmAccuracySum = 0; // Sum of all rhythm accuracy scores this session
                this.currentLevelRhythmBonus = 0; // Track rhythm bonus for current level only
                this.listenAgainUsed = false; // Track if Listen Again has been used this level

                // Level requirements: sequence length progression (3‚Üí4‚Üí4‚Üí5‚Üí5‚Üí6‚Üí6‚Üí7 etc.)
                this.levelRequirements = {
                    1: 3, // Level 1: 3 notes to complete
                    2: 4, // Level 2: 4 notes to complete
                    3: 4, // Level 3: 4 notes to complete (including A)
                    4: 5, // Level 4: 5 notes to complete
                    5: 5, // Level 5: 5 notes to complete
                    6: 6, // Level 6: 6 notes to complete  
                    7: 6, // Level 7: 6 notes to complete
                    8: 7, // Level 8: 7 notes to complete
                    9: 7, // Level 9: 7 notes to complete
                    10: 8, // Level 10: 8 notes to complete
                    11: 8, // Level 11: 8 notes to complete
                    12: 9, // Level 12: 9 notes to complete
                    13: 9, // Level 13: 9 notes to complete
                    14: 10, // Level 14: 10 notes to complete
                    15: 10, // Level 15: 10 notes to complete
                    16: 11, // Level 16: 11 notes to complete
                    17: 11, // Level 17: 11 notes to complete
                    18: 12, // Level 18: 12 notes to complete (max)
                    19: 12, // Level 19: 12 notes to complete
                    20: 12 // Level 20: 12 notes to complete
                };

                // Progressive note system by level - slower progression
                this.levelNotes = {
                    1: ['C', 'E', 'G'], // Level 1: CEG (3 notes)
                    2: ['C', 'E', 'G'], // Level 2: CEG (3 notes) 
                    3: ['C', 'E', 'G', 'A'], // Level 3: CEGA (4 notes)
                    4: ['C', 'E', 'G', 'A'], // Level 4: CEGA (4 notes)
                    5: ['C', 'E', 'G', 'A', 'D'], // Level 5: CEGAD (5 notes)
                    6: ['C', 'E', 'G', 'A', 'D'], // Level 6: CEGAD (5 notes)
                    7: ['C', 'D', 'E', 'G', 'A', 'F'], // Level 7: CDEGAF (6 notes)
                    8: ['C', 'D', 'E', 'G', 'A', 'F'], // Level 8: CDEGAF (6 notes)
                    9: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Level 9: CDEFGAB (7 notes)
                    10: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Level 10: CDEFGAB (7 notes)
                    11: ['C', 'D', 'D#', 'E', 'F', 'G', 'A', 'B'], // Level 11: Add D# (8 notes)
                    12: ['C', 'D', 'D#', 'E', 'F', 'G', 'A', 'B'], // Level 12: Add D# (8 notes)
                    13: ['C', 'D', 'D#', 'E', 'F', 'G', 'G#', 'A', 'B'], // Level 13: Add G# (9 notes)
                    14: ['C', 'D', 'D#', 'E', 'F', 'G', 'G#', 'A', 'B'], // Level 14: Add G# (9 notes)
                    15: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B'], // Level 15: Add F# (10 notes)
                    16: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B'], // Level 16: Add F# (10 notes)
                    17: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 17: Add A# (11 notes)
                    18: ['C', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 18: Add A# (11 notes)
                    19: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // Level 19: Add C# (12 notes - full chromatic)
                    20: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'] // Level 20: Full chromatic
                };

                // Rhythm definitions - simplified
                this.rhythms = {
                    quarter: { taps: 1, symbol: '‚ô©', name: 'Quarter' },
                    eighth: { taps: 2, symbol: '‚ô´', name: 'Eighth' },
                    triplet: { taps: 3, symbol: '¬≥', name: 'Triplet' },
                    sixteenth: { taps: 4, symbol: '‚ô¨', name: 'Sixteenth' }
                };

                // Shepard tone frequencies for one octave
                this.notes = {
                    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
                    'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
                };

                this.initializeAudio();
                this.initializeEventListeners();
                this.updateEnabledRhythms(); // Initialize rhythm settings
                this.updateDisplay();
                this.updateNoteDisplay();
                this.updateOptionsIndicator(); // Initialize options indicator
                this.updateLightColors(); // Initialize level 1 colors (blue)

                // Add interactive styles for option tags
                this.addInteractiveOptionStyles();

                // Track active oscillators for cleanup
                this.activeOscillators = [];

                // Load player data and always show welcome screen
                this.loadPlayerData();

                // Get reference to game board and hide it initially until welcome screen is closed
                this.gameBoard = document.querySelector('.game-board');

                // Always show welcome screen on startup
                this.showWelcomeScreen();
            }

            // Player data management
            loadPlayerData() {
                const savedData = localStorage.getItem('musicMatchPlayerData');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        this.playerName = data.playerName || '';
                        this.player2Name = data.player2Name || '';
                        this.playerStats = { ...this.playerStats, ...data.playerStats };
                        this.gameStarted = data.gameStarted || false;
                    } catch (e) {
                        console.log('Error loading player data, starting fresh');
                        this.gameStarted = false;
                    }
                } else {
                    this.gameStarted = false;
                }
            }

            savePlayerData() {
                // Don't save stats data when in 2-player mode (call-response mode)
                if (this.callResponseMode) {
                    return;
                }

                const data = {
                    playerName: this.playerName,
                    player2Name: this.player2Name,
                    playerStats: this.playerStats,
                    gameStarted: this.gameStarted
                };
                localStorage.setItem('musicMatchPlayerData', JSON.stringify(data));
            }

            updatePlayerStats(gameScore, gameLevel, rhythmAccuracy, pitchAccuracy) {
                // Don't track stats in 2-player mode (call-response mode)
                if (this.callResponseMode) {
                    return;
                }

                this.playerStats.totalGamesPlayed++;
                this.playerStats.bestScore = Math.max(this.playerStats.bestScore, gameScore);
                this.playerStats.bestLevel = Math.max(this.playerStats.bestLevel, gameLevel);

                // Add to session history (keep last 20 sessions)
                this.playerStats.sessionScores.push({
                    score: gameScore,
                    level: gameLevel,
                    date: new Date().toLocaleDateString(),
                    rhythmAccuracy: rhythmAccuracy,
                    pitchAccuracy: pitchAccuracy
                });

                if (this.playerStats.sessionScores.length > 20) {
                    this.playerStats.sessionScores.shift();
                }

                // Track accuracy history (keep last 10 games)
                this.playerStats.rhythmAccuracyHistory.push(rhythmAccuracy);
                this.playerStats.pitchAccuracyHistory.push(pitchAccuracy);

                if (this.playerStats.rhythmAccuracyHistory.length > 10) {
                    this.playerStats.rhythmAccuracyHistory.shift();
                }
                if (this.playerStats.pitchAccuracyHistory.length > 10) {
                    this.playerStats.pitchAccuracyHistory.shift();
                }

                this.savePlayerData();
            }

            // Welcome screen
            showWelcomeScreen() {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10001;
                    backdrop-filter: blur(10px);
                `;

                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #ffeaa7, #fab1a0);
                    border-radius: 20px;
                    padding: 40px;
                    text-align: center;
                    color: #2d3436;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 500px;
                    width: 90%;
                    animation: fadeInUp 0.6s ease-out;
                `;

                const welcomeMessage = this.playerName ?
                    `Welcome back, <strong>${this.playerName}</strong>! üéâ` :
                    'Welcome to Copy-Cat! üéµ';

                modal.innerHTML = `
                    <img src="Copycat logo.png" alt="Copy-Cat" style="max-height: 80px; max-width: 100%; object-fit: contain; margin-bottom: 20px;">
                    
                    <div style="font-size: 1.2rem; margin-bottom: 25px; line-height: 1.6;">
                        ${welcomeMessage}
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 15px; margin-bottom: 25px; text-align: left;">
                        <p style="margin: 0 0 15px 0; font-size: 1.1rem;"><strong>üéÆ How to Play:</strong></p>
                        <p style="margin: 0 0 10px 0;">‚Ä¢ Listen to the musical pattern and repeat it back</p>
                        <p style="margin: 0 0 10px 0;">‚Ä¢ Match both the notes and rhythm timing</p>
                        <p style="margin: 0 0 10px 0;">‚Ä¢ Progress through levels with more complex patterns</p>
                        <p style="margin: 0;">‚Ä¢ Challenge friends in 2-Player mode! üë•</p>
                    </div>

                    <div id="nameInputSection">
                        <div style="margin-bottom: 20px;">
                            <input type="text" id="playerNameInput" placeholder="Enter your name" 
                                value="${this.playerName}" 
                                style="padding: 12px 20px; border: 2px solid #ddd; border-radius: 25px; font-size: 1.1rem; width: 70%; text-align: center; margin-bottom: 15px;">
                        </div>
                        
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                            ${this.playerName ?
                        `<button id="continueAsBtn" style="background: linear-gradient(45deg, #00b894, #00cec9); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">Continue as ${this.playerName}</button>` :
                        ''
                    }
                            <button id="newPlayerBtn" style="background: linear-gradient(45deg, #fd79a8, #e84393); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">${this.playerName ? 'New Player' : 'Start Playing'}</button>
                            ${this.playerName ?
                        '<button id="viewStatsBtn" style="background: linear-gradient(45deg, #6c5ce7, #a29bfe); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">üìä View Progress</button>' :
                        ''
                    }
                        </div>
                    </div>
                `;

                // Add fade in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInUp {
                        from {
                            opacity: 0;
                            transform: translateY(30px);
                        }
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }
                `;
                document.head.appendChild(style);

                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Event listeners
                const nameInput = modal.querySelector('#playerNameInput');
                const continueBtn = modal.querySelector('#continueAsBtn');
                const newPlayerBtn = modal.querySelector('#newPlayerBtn');
                const viewStatsBtn = modal.querySelector('#viewStatsBtn');

                const startGame = (name) => {
                    if (name.trim()) {
                        this.playerName = name.trim();
                        this.gameStarted = true;
                        this.savePlayerData();
                        document.body.removeChild(overlay);
                        this.gameBoard.classList.add('show'); // Show game board after welcome screen
                        this.updateDisplay(); // Update display to show player name
                    } else {
                        nameInput.style.border = '2px solid #e74c3c';
                        nameInput.placeholder = 'Please enter your name!';
                    }
                };

                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        startGame(nameInput.value);
                    }
                });

                if (continueBtn) {
                    continueBtn.onclick = () => {
                        this.gameStarted = true;
                        this.savePlayerData();
                        document.body.removeChild(overlay);
                        this.gameBoard.classList.add('show'); // Show game board after welcome screen
                        this.updateDisplay();
                    };
                }

                newPlayerBtn.onclick = () => {
                    startGame(nameInput.value);
                };

                if (viewStatsBtn) {
                    viewStatsBtn.onclick = () => {
                        document.body.removeChild(overlay);
                        this.gameBoard.classList.add('show'); // Show game board after welcome screen
                        this.showProgressChart();
                    };
                }
            }

            // Progress chart and statistics
            showProgressChart() {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    padding: 20px 0;
                    z-index: 10001;
                    backdrop-filter: blur(10px);
                    overflow-y: auto;
                `;

                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #a8e6cf, #88d8c0);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: #2d3436;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 700px;
                    width: 90%;
                    max-height: 90vh;
                    overflow-y: auto;
                `;

                const createProgressBar = (label, percentage, color) => {
                    return `
                        <div style="margin: 15px 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="font-weight: bold;">${label}</span>
                                <span>${Math.round(percentage)}%</span>
                            </div>
                            <div style="background: rgba(255,255,255,0.3); border-radius: 10px; height: 20px; overflow: hidden;">
                                <div style="background: ${color}; height: 100%; width: ${percentage}%; transition: width 0.3s ease; border-radius: 10px;"></div>
                            </div>
                        </div>
                    `;
                };

                const createMiniChart = (data, label, color) => {
                    if (!data || data.length === 0) return `<div style="text-align: center; color: #666;">No data yet</div>`;

                    const max = Math.max(...data);
                    const min = Math.min(...data);
                    const range = max - min || 1;

                    return `
                        <div style="margin: 20px 0;">
                            <h4 style="margin-bottom: 10px;">${label}</h4>
                            <div style="display: flex; align-items: end; justify-content: center; gap: 3px; height: 60px; background: rgba(255,255,255,0.2); padding: 10px; border-radius: 10px;">
                                ${data.map(value => {
                        const height = range > 0 ? ((value - min) / range) * 40 + 10 : 25;
                        return `<div style="width: 20px; height: ${height}px; background: ${color}; border-radius: 2px;" title="${Math.round(value)}%"></div>`;
                    }).join('')}
                            </div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">Average: ${Math.round(data.reduce((a, b) => a + b, 0) / data.length)}%</div>
                        </div>
                    `;
                };

                // Calculate averages and convert to percentages for display
                const avgRhythm = this.playerStats.rhythmAccuracyHistory.length > 0 ?
                    (this.playerStats.rhythmAccuracyHistory.reduce((a, b) => a + b, 0) / this.playerStats.rhythmAccuracyHistory.length) * 100 : 0;
                const avgPitch = this.playerStats.pitchAccuracyHistory.length > 0 ?
                    (this.playerStats.pitchAccuracyHistory.reduce((a, b) => a + b, 0) / this.playerStats.pitchAccuracyHistory.length) * 100 : 0;

                modal.innerHTML = `
                    <h2 style="font-size: 2.2rem; margin-bottom: 25px; color: #2d3436;">üìä ${this.playerName}'s Progress üìä</h2>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                        <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 15px;">
                            <h3 style="margin-bottom: 15px; color: #6c5ce7;">üèÜ High Scores</h3>
                            <div style="font-size: 1.2rem; margin: 10px 0;"><strong>Best Score:</strong> ${this.playerStats.bestScore.toLocaleString()}</div>
                            <div style="font-size: 1.2rem; margin: 10px 0;"><strong>Best Level:</strong> ${this.playerStats.bestLevel}</div>
                            <div style="font-size: 1.1rem; margin: 10px 0;"><strong>Games Played:</strong> ${this.playerStats.totalGamesPlayed}</div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 15px;">
                            <h3 style="margin-bottom: 15px; color: #00b894;">üìà Current Averages</h3>
                            ${createProgressBar('Rhythm Accuracy', avgRhythm, 'linear-gradient(45deg, #667eea, #764ba2)')}
                            ${createProgressBar('Pitch Accuracy', avgPitch, 'linear-gradient(45deg, #00b894, #00cec9)')}
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                        <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 15px;">
                            ${createMiniChart(this.playerStats.rhythmAccuracyHistory.map(v => v * 100), 'ü•Å Rhythm Progress (Last 10 Games)', 'linear-gradient(45deg, #667eea, #764ba2)')}
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 15px;">
                            ${createMiniChart(this.playerStats.pitchAccuracyHistory.map(v => v * 100), 'üéµ Pitch Progress (Last 10 Games)', 'linear-gradient(45deg, #00b894, #00cec9)')}
                        </div>
                    </div>

                    ${this.playerStats.sessionScores.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                            <h3 style="margin-bottom: 15px; color: #e17055;">üìÖ Recent Sessions</h3>
                            <div style="max-height: 150px; overflow-y: auto;">
                                ${this.playerStats.sessionScores.slice(-5).reverse().map(session => `
                                    <div style="display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid #ddd; font-size: 0.95rem;">
                                        <span>${session.date}</span>
                                        <span>Score: ${session.score.toLocaleString()}</span>
                                        <span>Level: ${session.level}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}

                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button id="backToWelcomeBtn" style="background: linear-gradient(45deg, #fd79a8, #e84393); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">‚óÄÔ∏è Back</button>
                        <button id="startFromStatsBtn" style="background: linear-gradient(45deg, #00b894, #00cec9); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">üéÆ Start Playing</button>
                        <button id="newUserFromStatsBtn" style="background: linear-gradient(45deg, #6c5ce7, #a29bfe); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">üë§ New User</button>
                        <button id="resetStatsBtn" style="background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">üóëÔ∏è Reset Stats</button>
                    </div>
                `;

                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Event listeners
                modal.querySelector('#backToWelcomeBtn').onclick = () => {
                    document.body.removeChild(overlay);
                    this.showWelcomeScreen();
                };

                modal.querySelector('#startFromStatsBtn').onclick = () => {
                    document.body.removeChild(overlay);
                    this.gameStarted = true;
                    this.savePlayerData();
                    this.updateDisplay();
                };

                modal.querySelector('#newUserFromStatsBtn').onclick = () => {
                    document.body.removeChild(overlay);
                    this.startNewUser();
                };

                modal.querySelector('#resetStatsBtn').onclick = () => {
                    if (confirm('Are you sure you want to reset all your statistics? This cannot be undone.')) {
                        this.playerStats = {
                            totalGamesPlayed: 0,
                            bestLevel: 1,
                            bestScore: 0,
                            rhythmAccuracyHistory: [],
                            pitchAccuracyHistory: [],
                            sessionScores: []
                        };
                        this.savePlayerData();
                        document.body.removeChild(overlay);
                        this.showProgressChart(); // Refresh the chart
                    }
                };

                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        this.showWelcomeScreen();
                    }
                };
            }

            // Start new user flow - clear current data and show welcome screen
            startNewUser() {
                // Clear current user data
                this.playerName = '';
                this.player2Name = '';
                this.gameStarted = false;
                this.playerStats = {
                    totalGamesPlayed: 0,
                    bestLevel: 1,
                    bestScore: 0,
                    rhythmAccuracyHistory: [],
                    pitchAccuracyHistory: [],
                    sessionScores: []
                };

                // Save the cleared data
                this.savePlayerData();

                // Update display to hide player name
                this.updateDisplay();

                // Show welcome screen for new user
                this.showWelcomeScreen();
            }

            // Prompt for Player 2 name in 2-player mode
            promptForPlayer2Name() {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10001;
                    backdrop-filter: blur(10px);
                `;

                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #fd79a8, #fdcb6e);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                modal.innerHTML = `
                    <h2 style="font-size: 2rem; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">üë• 2 Player Mode! üë•</h2>
                    
                    <div style="font-size: 1.1rem; margin-bottom: 20px;">
                        <strong>${this.playerName}</strong> will create patterns<br>
                        <strong>${this.player2Name || 'Player 2'}</strong> will try to match them!
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <input type="text" id="player2NameInput" placeholder="Enter Player 2's name" 
                            value="${this.player2Name || ''}"
                            style="padding: 12px 20px; border: 2px solid white; border-radius: 25px; font-size: 1.1rem; width: 80%; text-align: center; margin-bottom: 15px;">
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button id="skipPlayer2NameBtn" style="background: rgba(255,255,255,0.2); color: white; border: 2px solid white; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">Skip (use "Player 2")</button>
                        <button id="setPlayer2NameBtn" style="background: linear-gradient(45deg, #00b894, #00cec9); color: white; border: none; padding: 12px 20px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer;">Let's Play!</button>
                    </div>
                `;

                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                const nameInput = modal.querySelector('#player2NameInput');
                const skipBtn = modal.querySelector('#skipPlayer2NameBtn');
                const setBtn = modal.querySelector('#setPlayer2NameBtn');

                const finishSetup = (name = '') => {
                    this.player2Name = name.trim() || 'Player 2';
                    this.savePlayerData();
                    document.body.removeChild(overlay);
                    // After setting name, continue with starting the game (skip the prompt this time)
                    this.startGame(true);
                };

                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        finishSetup(nameInput.value);
                    }
                });

                skipBtn.onclick = () => finishSetup();
                setBtn.onclick = () => finishSetup(nameInput.value);
            }

            // Add interactive styles for option tags
            addInteractiveOptionStyles() {
                const style = document.createElement('style');
                style.textContent = `
                    .option-tag {
                        cursor: pointer;
                        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
                        user-select: none;
                    }
                    
                    .option-tag:hover {
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                        background-color: rgba(255, 255, 255, 0.1);
                    }
                    
                    .option-tag:active {
                        transform: translateY(0);
                        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
                    }
                    
                    .rhythm-tag:hover {
                        background-color: rgba(102, 126, 234, 0.2);
                    }
                    
                    .note-tag:hover {
                        background-color: rgba(0, 184, 148, 0.2);
                    }
                    
                    .sound-tag:hover {
                        background-color: rgba(253, 121, 168, 0.2);
                    }
                    
                    .game-mode-tag:hover {
                        background-color: rgba(108, 92, 231, 0.2);
                    }

                    @keyframes rhythmPulse {
                        0% { 
                            transform: scale(1);
                            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.2);
                        }
                        50% { 
                            transform: scale(1.1);
                            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.6);
                        }
                        100% { 
                            transform: scale(1);
                            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.2);
                        }
                    }

                    .rhythm-tag.pulse {
                        animation: rhythmPulse 0.6s ease-in-out;
                    }

                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            async initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.setValueAtTime(0.8, this.audioContext.currentTime); // Increased volume
                } catch (error) {
                    console.error('Error initializing audio:', error);
                    alert('Audio initialization failed. Please try refreshing the page.');
                }
            }

            initializeEventListeners() {
                // Control buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('stopResetBtn').addEventListener('click', () => this.stopResetGame());
                document.getElementById('listenAgainBtn').addEventListener('click', () => this.listenAgain());

                // Options button - only works when stopped
                document.getElementById('optionsBtn').addEventListener('click', () => {
                    if (this.gameState === 'stopped') {
                        this.showOptionsModal();
                    }
                    // Do nothing during gameplay
                });

                document.getElementById('helpBtn').addEventListener('click', () => this.showHelpModal());

                // Player name display click - show progress chart
                document.getElementById('playerNameDisplay').addEventListener('click', () => {
                    if (this.playerName && this.gameStarted) {
                        this.showProgressChart();
                    }
                });

                // Global My Own Notes checkbox
                document.getElementById('useMyOwnNotesGlobal').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        // Enable custom note selection mode
                        this.usingCustomScale = true;
                        this.customNoteSelectionMode = true;

                        // Update radio button to custom
                        const customRadio = document.getElementById('scaleTypeCustom');
                        if (customRadio) {
                            customRadio.checked = true;
                        }

                        // Update displays
                        this.updateNoteDisplay();
                        this.updateOptionsIndicator();
                    } else {
                        // Disable custom note selection mode
                        this.usingCustomScale = false;
                        this.customNoteSelectionMode = false;

                        // Update radio button to progressive
                        const progressiveRadio = document.querySelector('input[name="scaleType"][value="progressive"]');
                        if (progressiveRadio) {
                            progressiveRadio.checked = true;
                        }

                        // Update displays
                        this.updateNoteDisplay();
                        this.updateOptionsIndicator();
                    }
                });

                // Rhythm toggle controls
                document.getElementById('rhythmQuarter').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmEighth').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmTriplet').addEventListener('change', () => this.updateEnabledRhythms());
                document.getElementById('rhythmSixteenth').addEventListener('change', () => this.updateEnabledRhythms());

                // Scale type controls
                document.querySelectorAll('input[name="scaleType"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.usingCustomScale = e.target.value === 'custom';
                        const customContainer = document.getElementById('customScaleContainer');

                        if (this.usingCustomScale) {
                            // Enter custom note selection mode
                            this.customNoteSelectionMode = true;
                            customContainer.style.display = 'none'; // Hide the checkboxes
                        } else {
                            // Exit custom note selection mode
                            this.customNoteSelectionMode = false;
                            customContainer.style.display = 'none';
                        }

                        this.updateNoteDisplay();
                        this.updateOptionsIndicator();
                    });
                });

                // Sound FX control
                document.getElementById('muteCheeringSound').addEventListener('change', () => {
                    this.updateOptionsIndicator();
                });

                // Custom note controls
                const noteCheckboxes = ['C', 'Csharp', 'D', 'Dsharp', 'E', 'F', 'Fsharp', 'G', 'Gsharp', 'A', 'Asharp', 'B'];
                noteCheckboxes.forEach(note => {
                    const checkbox = document.getElementById(`note${note}`);
                    if (checkbox) {
                        checkbox.addEventListener('change', () => this.updateCustomScale());
                    }
                });

                // Hide custom scale container when clicking outside
                document.addEventListener('click', (e) => {
                    const customContainer = document.getElementById('customScaleContainer');
                    const scaleControls = document.querySelector('.scale-controls');

                    // Check if click is outside the scale controls area and custom container is visible
                    if (this.usingCustomScale &&
                        customContainer &&
                        customContainer.style.display !== 'none' &&
                        !scaleControls.contains(e.target)) {

                        // Just hide the custom container, but keep custom mode active
                        customContainer.style.display = 'none';
                    }
                });

                // Light click events
                document.querySelectorAll('.light').forEach((light, index) => {
                    light.addEventListener('mousedown', (e) => this.onLightPress(index, e));
                    light.addEventListener('mouseup', (e) => this.onLightRelease(index, e));
                    light.addEventListener('mouseleave', (e) => this.onLightRelease(index, e));

                    // Touch events for mobile
                    light.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.onLightPress(index, e);
                    });
                    light.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.onLightRelease(index, e);
                    });
                });
            }

            // Stop all active audio
            stopAllAudio() {
                this.activeOscillators.forEach(osc => {
                    try {
                        if (osc && osc.stop) {
                            osc.stop();
                        }
                    } catch (e) {
                        // Oscillator may already be stopped
                    }
                });
                this.activeOscillators = [];
            }

            // Update light colors based on current level - cycling through spectrum
            updateLightColors() {
                // Calculate hue shift based on level (30 degrees per level around the color wheel)
                // Level 1 = 240¬∞ (blue), Level 2 = 270¬∞ (violet), Level 3 = 300¬∞ (magenta), etc.
                const baseHue = 240; // Start with blue
                const hueShift = (this.currentLevel - 1) * 30; // 30 degrees per level
                const currentHue = (baseHue + hueShift) % 360; // Wrap around after 360¬∞

                // Update background gradient to match the current level's hue
                const backgroundHue1 = currentHue;
                const backgroundHue2 = (currentHue + 20) % 360; // Slightly different hue for gradient
                const backgroundHue3 = (currentHue + 40) % 360; // Third color for richer gradient

                // Create a sophisticated gradient background that complements the light colors
                const background = `linear-gradient(135deg, 
                    hsl(${backgroundHue1}, 70%, 15%), 
                    hsl(${backgroundHue2}, 75%, 20%), 
                    hsl(${backgroundHue3}, 80%, 25%)
                )`;

                // Apply background to body with smooth transition
                document.body.style.background = background;

                // Define 12 equally spaced hues around the color wheel for the 12 lights
                const lights = document.querySelectorAll('.light');
                lights.forEach((light, index) => {
                    // Spread the 12 lights evenly around the color wheel from the current level's base hue
                    const lightHue = (currentHue + (index * 30)) % 360; // 30¬∞ spacing between lights

                    // Use consistent saturation and lightness for good visibility
                    const saturation = 85; // High saturation for vibrant colors
                    const lightness = 58; // Good contrast against white text

                    // Create the gradient using HSL
                    const color1 = `hsl(${lightHue}, ${saturation}%, ${lightness}%)`;
                    const color2 = `hsl(${lightHue}, ${saturation}%, ${lightness - 10}%)`; // Slightly darker for gradient

                    // Apply the new gradient background
                    light.style.background = `linear-gradient(45deg, ${color1}, ${color2}) !important`;
                });

                // Optional: Add a visual feedback animation when colors change
                lights.forEach(light => {
                    light.style.transition = 'background 1s ease-in-out';
                });

                console.log(`üé® Level ${this.currentLevel}: Updated to hue ${currentHue}¬∞ with matching background`);
            }

            // User feedback tone with proper duration matching the rhythm
            playUserFeedbackTone(frequency, rhythmData) {
                if (!this.audioContext) return;

                try {
                    // Calculate the full duration this rhythm should have
                    const beatDuration = (60000 / this.bpm); // Keep in milliseconds
                    let subdivisionDuration = beatDuration / rhythmData.taps;

                    // Set minimum subdivision duration to prevent overlapping
                    const minSubdivisionDuration = 150; // Minimum 150ms between notes
                    if (subdivisionDuration < minSubdivisionDuration) {
                        subdivisionDuration = minSubdivisionDuration;
                    }

                    const noteDuration = (subdivisionDuration * 0.6) / 1000; // Convert to seconds, 60% for note

                    // Create Shepard tone with multiple octaves - same as sequence playback
                    const octaves = [1, 2, 4, 8]; // Four octaves
                    const gains = [0.3, 0.4, 0.4, 0.3]; // Bell curve weighting
                    const currentTime = this.audioContext.currentTime;

                    octaves.forEach((octaveMultiplier, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        // Set frequency for this octave
                        const octaveFreq = frequency * octaveMultiplier;
                        osc.frequency.setValueAtTime(octaveFreq, currentTime);
                        osc.type = 'sine';

                        // Envelope with proper decay length matching the rhythm
                        const maxGain = gains[index] * 0.18; // Slightly louder for user feedback
                        gain.gain.setValueAtTime(0, currentTime);
                        gain.gain.linearRampToValueAtTime(maxGain, currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(maxGain * 0.4, currentTime + noteDuration * 0.5);
                        gain.gain.exponentialRampToValueAtTime(0.001, currentTime + noteDuration);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        // Schedule start and stop
                        osc.start(currentTime);
                        osc.stop(currentTime + noteDuration);

                        // Track for cleanup
                        this.activeOscillators.push(osc);

                        // Remove from tracking when it naturally ends
                        osc.onended = () => {
                            const index = this.activeOscillators.indexOf(osc);
                            if (index > -1) {
                                this.activeOscillators.splice(index, 1);
                            }
                        };
                    });

                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }

            // Shepard tone generator with proper note durations
            playTone(frequency, noteDurationMs) {
                if (!this.audioContext) return;

                try {
                    // Convert milliseconds to seconds
                    const noteDuration = noteDurationMs / 1000;

                    // Create Shepard tone with multiple octaves
                    const octaves = [1, 2, 4, 8]; // Four octaves
                    const gains = [0.3, 0.4, 0.4, 0.3]; // Bell curve weighting
                    const currentTime = this.audioContext.currentTime;

                    octaves.forEach((octaveMultiplier, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        // Set frequency for this octave
                        const octaveFreq = frequency * octaveMultiplier;
                        osc.frequency.setValueAtTime(octaveFreq, currentTime);
                        osc.type = 'sine';

                        // Envelope with decay
                        const maxGain = gains[index] * 0.12; // Reduced volume further
                        gain.gain.setValueAtTime(0, currentTime);
                        gain.gain.linearRampToValueAtTime(maxGain, currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(maxGain * 0.4, currentTime + noteDuration * 0.5);
                        gain.gain.exponentialRampToValueAtTime(0.001, currentTime + noteDuration);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        // Schedule start and stop
                        osc.start(currentTime);
                        osc.stop(currentTime + noteDuration);

                        // Track for cleanup
                        this.activeOscillators.push(osc);

                        // Remove from tracking when it naturally ends
                        osc.onended = () => {
                            const index = this.activeOscillators.indexOf(osc);
                            if (index > -1) {
                                this.activeOscillators.splice(index, 1);
                            }
                        };
                    });

                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }

            // Update enabled rhythms based on checkboxes
            updateEnabledRhythms() {
                this.enabledRhythms = [];
                if (document.getElementById('rhythmQuarter').checked) this.enabledRhythms.push('quarter');
                if (document.getElementById('rhythmEighth').checked) this.enabledRhythms.push('eighth');
                if (document.getElementById('rhythmTriplet').checked) this.enabledRhythms.push('triplet');
                if (document.getElementById('rhythmSixteenth').checked) this.enabledRhythms.push('sixteenth');

                // Ensure at least one rhythm is enabled
                if (this.enabledRhythms.length === 0) {
                    this.enabledRhythms.push('quarter');
                    document.getElementById('rhythmQuarter').checked = true;
                }

                // Update the options indicator
                this.updateOptionsIndicator();
            }

            // Update custom scale based on note checkboxes
            updateCustomScale() {
                this.customNotes = [];
                const noteMap = {
                    'C': 'C', 'Csharp': 'C#', 'D': 'D', 'Dsharp': 'D#',
                    'E': 'E', 'F': 'F', 'Fsharp': 'F#', 'G': 'G',
                    'Gsharp': 'G#', 'A': 'A', 'Asharp': 'A#', 'B': 'B'
                };

                Object.keys(noteMap).forEach(checkboxId => {
                    const checkbox = document.getElementById(`note${checkboxId}`);
                    if (checkbox && checkbox.checked) {
                        this.customNotes.push(noteMap[checkboxId]);
                    }
                });

                // Ensure at least one note is selected
                if (this.customNotes.length === 0) {
                    this.customNotes.push('C');
                    document.getElementById('noteC').checked = true;
                }

                this.updateNoteDisplay();
            }

            // Update note display based on available notes
            updateNoteDisplay() {
                const lights = document.querySelectorAll('.light');
                const container = document.querySelector('.notes-container');
                const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

                // Always use linear layout (horizontal) - remove any circular layout
                container.classList.remove('circular-layout');
                container.classList.add('linear-layout');
                container.style.width = 'auto';
                container.style.height = '180px';

                if (this.customNoteSelectionMode) {
                    // Custom note selection mode - show all notes, some ghosted
                    container.classList.add('custom-note-selection-mode');

                    lights.forEach((light, index) => {
                        const note = chromaticScale[index];
                        light.dataset.note = note;
                        light.querySelector('.light-number').textContent = note;
                        light.style.display = 'flex';
                        light.style.opacity = '1';
                        light.style.pointerEvents = 'auto';

                        // Clear any inline positioning styles
                        light.style.left = '';
                        light.style.top = '';
                        light.style.transform = '';

                        // Add classes based on selection state
                        if (this.customNotes.includes(note)) {
                            light.classList.add('selected');
                            light.classList.remove('ghosted');
                        } else {
                            light.classList.add('ghosted');
                            light.classList.remove('selected');
                        }
                    });

                    // Show save button
                    this.showSaveCustomNotesButton();
                } else {
                    // Normal mode - show only available notes
                    container.classList.remove('custom-note-selection-mode');
                    const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);

                    let visibleIndex = 0;
                    lights.forEach((light, index) => {
                        const note = chromaticScale[index];
                        light.dataset.note = note;
                        light.querySelector('.light-number').textContent = note;

                        // Remove custom selection classes
                        light.classList.remove('selected', 'ghosted');

                        if (availableNotes.includes(note)) {
                            light.style.display = 'flex';
                            light.style.opacity = '1';
                            light.style.pointerEvents = 'auto';

                            // Clear any inline positioning styles
                            light.style.left = '';
                            light.style.top = '';
                            light.style.transform = '';

                            visibleIndex++;
                        } else {
                            light.style.display = 'none';
                        }
                    });

                    // Hide save button
                    this.hideSaveCustomNotesButton();
                }
            }            // Get available notes for current level
            getAvailableNotesForLevel(level = null) {
                if (this.usingCustomScale) {
                    return this.customNotes;
                }
                // Use current level, not round
                const currentLevel = level || this.currentLevel;
                const clampedLevel = Math.min(currentLevel, 10);
                return this.levelNotes[clampedLevel] || this.levelNotes[10];
            }

            // Show save button for custom note selection
            showSaveCustomNotesButton() {
                // Remove existing button if present
                const existingBtn = document.getElementById('saveCustomNotesBtn');
                if (existingBtn) {
                    existingBtn.remove();
                }

                const saveBtn = document.createElement('button');
                saveBtn.id = 'saveCustomNotesBtn';
                saveBtn.className = 'save-custom-notes-btn';
                saveBtn.innerHTML = 'üíæ Save My Notes';
                saveBtn.onclick = () => this.saveCustomNotes();
                document.body.appendChild(saveBtn);
            }

            // Hide save button
            hideSaveCustomNotesButton() {
                const saveBtn = document.getElementById('saveCustomNotesBtn');
                if (saveBtn) {
                    saveBtn.remove();
                }
            }

            // Handle note light click in custom selection mode
            handleCustomNoteSelection(noteIndex) {
                if (!this.customNoteSelectionMode) return;

                const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const note = chromaticScale[noteIndex];
                const light = document.getElementById(`light-${noteIndex}`);

                if (this.customNotes.includes(note)) {
                    // Remove note
                    this.customNotes = this.customNotes.filter(n => n !== note);
                    light.classList.remove('selected');
                    light.classList.add('ghosted');
                } else {
                    // Add note
                    this.customNotes.push(note);
                    light.classList.remove('ghosted');
                    light.classList.add('selected');
                }

                // Ensure at least one note is selected
                if (this.customNotes.length === 0) {
                    this.customNotes.push('C');
                    const cLight = document.getElementById('light-0');
                    cLight.classList.remove('ghosted');
                    cLight.classList.add('selected');
                }

                // Update the custom scale checkboxes to match
                this.syncCustomNotesToCheckboxes();
            }

            // Save custom notes and exit selection mode
            saveCustomNotes() {
                this.customNoteSelectionMode = false;
                this.updateNoteDisplay();
                this.updateOptionsIndicator();

                // Update the custom scale container visibility
                const customContainer = document.getElementById('customScaleContainer');
                customContainer.style.display = 'none';

                // Show success message
                this.showCustomNotesSavedMessage();
            }

            // Show success message for saved notes
            showCustomNotesSavedMessage() {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #00b894, #00cec9);
                    color: white;
                    padding: 20px 40px;
                    border-radius: 20px;
                    font-size: 1.2rem;
                    font-weight: bold;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                    z-index: 10001;
                    border: 3px solid white;
                    font-family: 'Comic Sans MS', sans-serif;
                `;
                message.textContent = `‚úÖ Saved ${this.customNotes.length} notes: ${this.customNotes.join(', ')}`;
                document.body.appendChild(message);

                setTimeout(() => {
                    message.remove();
                }, 2000);
            }

            // Sync custom notes to the checkboxes in the options
            syncCustomNotesToCheckboxes() {
                const noteMap = {
                    'C': 'noteC', 'C#': 'noteCsharp', 'D': 'noteD', 'D#': 'noteDsharp',
                    'E': 'noteE', 'F': 'noteF', 'F#': 'noteFsharp', 'G': 'noteG',
                    'G#': 'noteGsharp', 'A': 'noteA', 'A#': 'noteAsharp', 'B': 'noteB'
                };

                Object.entries(noteMap).forEach(([note, checkboxId]) => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        checkbox.checked = this.customNotes.includes(note);
                    }
                });
            }

            // Generate random sequence item - only from available notes and enabled rhythms
            generateSequenceItem() {
                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

                // Find positions that have available notes
                const availablePositions = [];
                chromaticScale.forEach((note, index) => {
                    if (availableNotes.includes(note)) {
                        availablePositions.push(index);
                    }
                });

                if (availablePositions.length === 0) {
                    // Fallback to position 0 if no notes available
                    availablePositions.push(0);
                }

                let lightIndex;

                // Improved randomization to avoid repetitive patterns
                if (this.lastNoteIndex === -1 || availablePositions.length <= 2) {
                    // First note or very few options - pick randomly
                    lightIndex = availablePositions[Math.floor(Math.random() * availablePositions.length)];
                } else {
                    // Create weighted selection to encourage variety
                    const weights = [];
                    const recentNotes = this.gameSequence.slice(-3).map(item => item.lightIndex); // Last 3 notes

                    for (const pos of availablePositions) {
                        if (pos === this.lastNoteIndex) {
                            // Never repeat the immediate previous note
                            continue;
                        }

                        let weight = 1.0;

                        // Reduce weight if note was used recently (within last 3)
                        const recentCount = recentNotes.filter(recent => recent === pos).length;
                        if (recentCount > 0) {
                            weight = 0.3; // Much lower weight for recently used notes
                        }

                        // Slightly favor notes that haven't been used at all yet
                        const usedInSequence = this.gameSequence.some(item => item.lightIndex === pos);
                        if (!usedInSequence) {
                            weight += 0.5; // Bonus for unused notes
                        }

                        weights.push({ pos, weight });
                    }

                    // If all notes are heavily weighted down, reset to equal weights
                    if (weights.length === 0 || weights.every(w => w.weight < 0.5)) {
                        lightIndex = availablePositions.filter(pos => pos !== this.lastNoteIndex)[0] ||
                            availablePositions[Math.floor(Math.random() * availablePositions.length)];
                    } else {
                        // Weighted random selection
                        const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
                        let random = Math.random() * totalWeight;

                        for (const w of weights) {
                            random -= w.weight;
                            if (random <= 0) {
                                lightIndex = w.pos;
                                break;
                            }
                        }

                        // Fallback if something went wrong
                        if (lightIndex === undefined) {
                            lightIndex = weights[0].pos;
                        }
                    }
                }

                // Store this position for next time
                this.lastNoteIndex = lightIndex;

                // Improved rhythm randomization - favor variety
                const enabledRhythmKeys = this.enabledRhythms;
                let rhythmKey;

                if (this.gameSequence.length === 0) {
                    // First item - any rhythm is fine
                    rhythmKey = enabledRhythmKeys[Math.floor(Math.random() * enabledRhythmKeys.length)];
                } else {
                    // Check last few rhythms to encourage variety
                    const recentRhythms = this.gameSequence.slice(-2).map(item => item.rhythm);
                    const availableRhythms = enabledRhythmKeys.filter(r => !recentRhythms.includes(r));

                    if (availableRhythms.length > 0 && Math.random() < 0.7) {
                        // 70% chance to use a rhythm that wasn't used recently
                        rhythmKey = availableRhythms[Math.floor(Math.random() * availableRhythms.length)];
                    } else {
                        // 30% chance to use any rhythm (allows some repetition)
                        rhythmKey = enabledRhythmKeys[Math.floor(Math.random() * enabledRhythmKeys.length)];
                    }
                }

                const light = document.getElementById(`light-${lightIndex}`);
                const note = light.dataset.note;

                return {
                    lightIndex,
                    note,
                    rhythm: rhythmKey,
                    rhythmData: this.rhythms[rhythmKey]
                };
            }

            // Start new game - faster setup
            async startGame(skipPrompt = false) {
                // Check if we're in "My Own Notes" mode but haven't saved custom notes
                const useMyOwnNotesGlobal = document.getElementById('useMyOwnNotesGlobal');
                if (useMyOwnNotesGlobal && useMyOwnNotesGlobal.checked && this.customNotes.length === 0) {
                    alert('Please select and save your custom notes before starting the game!');
                    return;
                }

                // If in 2-player mode and we haven't skipped the prompt, always prompt for Player 2 name to confirm/change it
                if (this.callResponseMode && !skipPrompt) {
                    this.promptForPlayer2Name();
                    return; // Don't start the game yet, wait for name input
                }

                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.gameState = 'playing';
                this.playerSequence = [];
                this.currentRound = 1;
                this.currentLevel = 1; // Reset to level 1
                this.correctInRow = 0; // Reset progression counter
                this.bpm = 50; // Reset BPM to starting value (50 BPM)
                this.lastNoteIndex = -1; // Reset note tracking
                this.lives = 3; // Reset lives to 3

                // Update light colors for level 1 (blue)
                this.updateLightColors();

                // Reset Listen Again bonus system
                this.normalListenAgainCount = 1; // Reset to normal
                this.bonusListenAgainAwarded = false; // Reset bonus tracking

                // Reset game mode specific variables
                if (this.callResponseMode) {
                    this.isPlayer1Turn = true; // Start with Player 1 in call & response
                    this.player1Sequence = [];
                    this.callResponseRound = 1; // Reset to round 1
                } else {
                    this.isPlayer1Turn = false; // Not relevant for other modes
                }

                if (this.pitchTrainingMode) {
                    this.pitchTrainingListenCount = 0; // Reset listen count for pitch training
                }

                // Start with one simple item
                this.gameSequence = [this.generateSequenceItem()];

                // Reset scoring
                this.totalScore = 0;
                this.levelScore = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.currentLevelRhythmBonus = 0; // Reset rhythm bonus for new game
                this.listenAgainUsed = false; // Reset Listen Again for new game

                this.updateDisplay();
                this.updateControls();
                this.updateNoteDisplay(); // Ensure proper note display for level 1
                this.switchToInGameUI(); // Switch to in-game UI layout

                // Handle different game modes
                if (this.callResponseMode) {
                    // In call & response mode, start with Player 1's turn
                    this.startCallResponseTurn();
                } else {
                    // Normal mode or pitch training - start playing sequence
                    setTimeout(() => {
                        // Play start round sound only if Sound FX is enabled
                        const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                        if (soundFxEnabled) {
                            const startRoundAudio = new Audio('startround.mp3');
                            startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                        }

                        // Show "Get Ready!" modal for 3 seconds, then start sequence
                        this.showGetReadyModal(() => {
                            if (this.pitchTrainingMode) {
                                this.playSequenceWithPitchTraining();
                            } else {
                                this.playSequence();
                            }
                        });
                    }, 300);
                }
            }

            // Start a turn in Call & Response mode
            async startCallResponseTurn() {
                // Ensure audio context is ready to prevent glitches
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                if (this.isPlayer1Turn) {
                    // Player 1's turn - they create the call
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls();

                    // Only show instruction modal for the first round
                    if (this.callResponseRound === 1) {
                        const player1Name = this.playerName || 'Player 1';
                        const player2Name = this.player2Name || 'Player 2';
                        this.showCallResponseInstruction(`Ready ${player1Name}!`, `Start playing notes to create a pattern for ${player2Name} to copy.`);
                    } else {
                        // Directly start Player 1's input for subsequent rounds
                        this.startPlayer1Input();
                    }
                } else {
                    // Player 2's turn - they respond to Player 1's call
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls();

                    // Only show instruction modal for the first round
                    if (this.callResponseRound === 1) {
                        const player1Name = this.playerName || 'Player 1';
                        const player2Name = this.player2Name || 'Player 2';
                        this.showCallResponseInstruction(`Ready ${player2Name}!`, `Copy the pattern that ${player1Name} just played.`);
                    } else {
                        // Directly start Player 2's input for subsequent rounds
                        this.startPlayer2Input();
                    }
                }
            }

            // Show instruction modal for call and response mode
            showCallResponseInstruction(title, message) {
                // Create instruction overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(5px);
                `;

                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                const titleElement = document.createElement('div');
                titleElement.textContent = title;
                titleElement.style.cssText = `
                    font-size: 1.8rem;
                    font-weight: bold;
                    margin-bottom: 15px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                `;

                const messageElement = document.createElement('div');
                messageElement.textContent = message;
                messageElement.style.cssText = `
                    font-size: 1.2rem;
                    margin-bottom: 20px;
                    line-height: 1.4;
                `;

                const readyButton = document.createElement('button');
                readyButton.textContent = 'Ready!';
                readyButton.style.cssText = `
                    background: linear-gradient(45deg, #28a745, #20c997);
                    color: white;
                    border: none;
                    padding: 12px 25px;
                    border-radius: 25px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;

                readyButton.onmouseover = () => {
                    readyButton.style.transform = 'translateY(-2px)';
                    readyButton.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                readyButton.onmouseout = () => {
                    readyButton.style.transform = 'translateY(0)';
                    readyButton.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };

                readyButton.onclick = () => {
                    document.body.removeChild(overlay);
                    // Start the actual turn after instruction is dismissed
                    if (this.isPlayer1Turn) {
                        this.startPlayer1Input();
                    } else {
                        this.startPlayer2Input();
                    }
                };

                // Auto-dismiss after 1.5 seconds
                setTimeout(() => {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        // Start the actual turn after auto-dismiss
                        if (this.isPlayer1Turn) {
                            this.startPlayer1Input();
                        } else {
                            this.startPlayer2Input();
                        }
                    }
                }, 1500);

                modal.appendChild(titleElement);
                modal.appendChild(messageElement);
                modal.appendChild(readyButton);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
            }

            // Start Player 1's input phase
            async startPlayer1Input() {
                // Ensure audio context is ready to prevent glitches
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.player1Sequence = [];
                this.lastPlayer1InputTime = Date.now();

                // Start monitoring for 1.5 seconds of silence to end Player 1's turn
                this.checkPlayer1Silence();
            }

            // Check if Player 1 has been silent for 1.5 seconds
            checkPlayer1Silence() {
                const checkInterval = 100; // Check every 100ms
                const silenceThreshold = 1500; // 1.5 seconds of silence

                this.silenceCheckInterval = setInterval(() => {
                    const now = Date.now();
                    const timeSinceLastInput = now - this.lastPlayer1InputTime;

                    if (this.player1Sequence.length > 0 && timeSinceLastInput >= silenceThreshold) {
                        // Player 1 has been silent for 1.5 seconds and has played at least one note
                        clearInterval(this.silenceCheckInterval);
                        this.endPlayer1Call();
                    }
                }, checkInterval);
            }

            // Start Player 2's input phase
            async startPlayer2Input() {
                // Ensure audio context is ready to prevent glitches
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.playerSequence = [];

                // Set timeout for Player 2's entire response (10 seconds)
                this.callResponseTimeout = setTimeout(() => {
                    this.compareCallResponse();
                }, 10000);
            }

            // Stop and reset game combined (for single button)
            stopResetGame() {
                this.resetGame();
                this.switchToPreGameUI();
            }

            // Stop game
            stopGame() {
                this.gameState = 'stopped';
                this.stopAllAudio(); // Stop any playing audio
                this.clearAllTimeouts();
                this.clearAllLights();

                // Clear call and response specific timers
                if (this.silenceCheckInterval) {
                    clearInterval(this.silenceCheckInterval);
                    this.silenceCheckInterval = null;
                }
                if (this.callResponseTimeout) {
                    clearTimeout(this.callResponseTimeout);
                    this.callResponseTimeout = null;
                }

                this.updateDisplay();
                this.updateControls();
                this.switchToPreGameUI();
            }

            // Reset game
            resetGame() {
                this.stopGame();
                this.gameSequence = [];
                this.playerSequence = [];
                this.currentRound = 1;
                this.currentLevel = 1; // Reset to level 1
                this.correctInRow = 0; // Reset progression counter
                this.bpm = 50; // Reset BPM to starting value (50 BPM)
                this.lastNoteIndex = -1; // Reset note tracking
                this.lives = 3; // Reset lives to 3
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.currentItemTapTimes = []; // Reset tap times tracking

                // Update light colors back to level 1 (blue)
                this.updateLightColors();

                // Reset scoring and rhythm accuracy tracking
                this.totalScore = 0;
                this.levelScore = 0;
                this.rhythmAccuracy = 0;
                this.perfectTimingCount = 0;
                this.totalTimingAttempts = 0;
                this.sessionRhythmAccuracySum = 0;
                this.currentLevelRhythmBonus = 0;

                // Reset Listen Again bonus system
                this.normalListenAgainCount = 1; // Reset to normal
                this.bonusListenAgainAwarded = false; // Reset bonus tracking
                this.listenAgainUsed = false; // Reset Listen Again usage

                this.updateDisplay();
                this.updateNoteDisplay(); // Refresh notes for level 1
                this.updateControls(); // Update button states
            }

            // UI switching methods
            switchToInGameUI() {
                // Hide pre-game UI elements
                document.getElementById('preGameUI').style.display = 'none';

                // Show in-game UI elements
                document.getElementById('inGameUI').style.display = 'block';

                // Update the current level display
                this.updateLevelDisplay();
            }

            switchToPreGameUI() {
                // Show pre-game UI elements
                document.getElementById('preGameUI').style.display = 'block';

                // Hide in-game UI elements
                document.getElementById('inGameUI').style.display = 'none';
            }

            updateLevelDisplay() {
                // Update the level display in the in-game UI
                const currentLevelSpan = document.getElementById('currentLevel');
                if (currentLevelSpan) {
                    currentLevelSpan.textContent = this.currentLevel;
                }
            }

            // Special sequence playback for pitch training mode - only shows first note visually
            playSequenceWithPitchTraining() {
                this.gameState = 'playing';
                this.updateDisplay();

                let delay = 0;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                this.gameSequence.forEach((item, index) => {
                    setTimeout(() => {
                        if (index === 0) {
                            // Only animate the first note of the entire sequence visually
                            this.playSequenceItem(item, true);
                        } else {
                            // Play audio only for all other notes (no visual animation)
                            this.playSequenceItem(item, false);
                        }
                    }, delay);

                    // Each round takes exactly one beat duration, regardless of subdivisions
                    delay += beatDuration; // No gaps - each round is exactly 1 beat
                });

                // Switch to player turn after sequence completes - no extra delay
                setTimeout(() => {
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls(); // Update button states including Listen Again
                }, delay);
            }

            // Play sequence - each round is exactly 1 beat duration
            playSequence() {
                this.gameState = 'playing';
                this.updateDisplay();

                let delay = 0;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                this.gameSequence.forEach((item, index) => {
                    setTimeout(() => {
                        this.playSequenceItem(item);
                    }, delay);

                    // Each round takes exactly one beat duration, regardless of subdivisions
                    delay += beatDuration; // No gaps - each round is exactly 1 beat
                });

                // Switch to player turn after sequence completes - no extra delay
                setTimeout(() => {
                    this.gameState = 'listening';
                    this.isPlayerTurn = true;
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.updateDisplay();
                    this.updateControls(); // Update button states including Listen Again
                }, delay); // Removed the +200ms delay
            }

            // Play individual sequence item - subdivisions within one beat with proper timing
            playSequenceItem(item, visual = true) {
                const light = document.getElementById(`light-${item.lightIndex}`);
                const frequency = this.notes[item.note];
                const tapsToPlay = item.rhythmData.taps;
                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms

                // Calculate subdivision timing within the beat
                let subdivisionDuration = beatDuration / tapsToPlay; // Each tap gets equal share of the beat

                // Set minimum subdivision duration to prevent overlapping (especially for 16th notes)
                const minSubdivisionDuration = 150; // Minimum 150ms between notes
                if (subdivisionDuration < minSubdivisionDuration) {
                    subdivisionDuration = minSubdivisionDuration;
                }

                const noteDuration = subdivisionDuration * 0.6; // 60% of subdivision for note (reduced to prevent overlap)
                const gapDuration = subdivisionDuration * 0.4; // 40% gap (increased for cleaner separation)

                // Visual and audio for each subdivision
                for (let i = 0; i < tapsToPlay; i++) {
                    setTimeout(() => {
                        // Visual flash - duration matches note duration (only 'playing' class for sequence)
                        if (visual) {
                            light.classList.add('playing');
                            setTimeout(() => {
                                light.classList.remove('playing');
                            }, noteDuration);
                        }
                        // Audio with Shepard tone and proper duration
                        this.playTone(frequency, noteDuration); // Use noteDuration instead of subdivisionDuration
                    }, i * subdivisionDuration);
                }
            }

            // Play sequence item audio only (no visual animation) - for pitch training mode
            playSequenceItemAudioOnly(item) {
                // Call playSequenceItem with visual = false
                this.playSequenceItem(item, false);
            }

            // Listen Again function - replay current sequence
            listenAgain() {
                if (this.gameState !== 'listening' || !this.isPlayerTurn) {
                    return; // Can't use if not in listening state or not player turn
                }

                if (this.pitchTrainingMode) {
                    // In pitch training mode, allow 2 Listen Again uses
                    if (this.pitchTrainingListenCount >= 2) {
                        return; // Already used both listens
                    }
                    this.pitchTrainingListenCount++;
                } else {
                    // Normal mode - check if any listens remain
                    const remainingListens = this.normalListenAgainCount - (this.listenAgainUsed ? 1 : 0);
                    if (remainingListens <= 0) {
                        return; // No listens remaining
                    }
                    this.listenAgainUsed = true;
                }

                // Temporarily disable player turn and replay sequence
                this.isPlayerTurn = false;
                this.gameState = 'playing';
                this.updateDisplay(); // Update display to show remaining listens
                this.updateControls(); // Update button states

                // Replay the current sequence
                if (this.pitchTrainingMode) {
                    this.playSequenceWithPitchTraining();
                } else {
                    this.playSequence();
                }
            }

            // Handle light press - simplified validation with timing tolerance
            onLightPress(lightIndex, event) {
                // Prevent default touch behavior to avoid glitches
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }

                // Resume audio context if suspended (required for mobile browsers)
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                // Handle custom note selection mode
                if (this.customNoteSelectionMode) {
                    this.handleCustomNoteSelection(lightIndex);
                    return;
                }

                // If game is active and waiting for player input, handle as gameplay
                if (this.gameState === 'listening' && this.isPlayerTurn) {
                    // Handle different game modes
                    if (this.callResponseMode) {
                        this.handleCallResponsePress(lightIndex);
                    } else {
                        this.handleNormalGamePress(lightIndex);
                    }
                    return;
                }

                // If no game is active (stopped state), just play the note for preview
                if (this.gameState === 'stopped') {
                    const light = document.getElementById(`light-${lightIndex}`);
                    const note = light.dataset.note;
                    const frequency = this.notes[note];

                    // Play note with visual feedback
                    light.classList.add('active');
                    this.playTone(frequency, 300); // Play for 300ms (corrected units)

                    // Remove visual feedback after 300ms
                    setTimeout(() => {
                        light.classList.remove('active');
                    }, 300);

                    return;
                }

                // During sequence playback or other game states, ignore input
                return;
            }

            // Handle input for normal game mode (including pitch training)
            handleNormalGamePress(lightIndex) {
                const expectedItem = this.gameSequence[this.currentSequenceIndex];
                if (!expectedItem) return;

                // Check correct light
                if (lightIndex !== expectedItem.lightIndex) {
                    this.loseLife();
                    return;
                }

                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.add('active');

                // PLAY AUDIO FEEDBACK with proper duration matching the expected rhythm
                const note = light.dataset.note;
                const frequency = this.notes[note];
                this.playUserFeedbackTone(frequency, expectedItem.rhythmData);

                // Track timing for validation - start timing from first note press
                if (this.currentTapCount === 0) {
                    this.tapStartTime = Date.now();
                    this.currentItemStartTime = Date.now(); // Track when this item started
                    this.currentItemTapTimes = []; // Track individual tap times for this item
                }

                // Record this tap time
                this.currentItemTapTimes.push(Date.now());
                this.currentTapCount++;

                // Check if we've got enough taps
                const requiredTaps = expectedItem.rhythmData.taps;
                if (this.currentTapCount >= requiredTaps) {
                    // Basic validation - ensure correct number of taps
                    if (this.currentTapCount > 1) {
                        const totalTime = Date.now() - this.tapStartTime;
                        const beatDuration = 60000 / this.bpm; // Duration of one beat in ms
                        const expectedTime = (requiredTaps - 1) * (beatDuration / requiredTaps); // Subdivisions within beat

                        // Basic acceptance tolerance (50%) - too slow fails
                        const basicTolerance = expectedTime * 0.5;
                        if (totalTime > expectedTime + basicTolerance) {
                            this.loseLife();
                            return;
                        }
                    }

                    // Success! Move to next item
                    this.playerSequence.push({
                        lightIndex,
                        note: light.dataset.note,
                        rhythm: expectedItem.rhythm,
                        tapCount: this.currentTapCount,
                        startTime: this.currentItemStartTime,
                        endTime: Date.now(),
                        tapTimes: [...this.currentItemTapTimes] // Store all individual tap times
                    });

                    this.currentSequenceIndex++;
                    this.currentTapCount = 0;
                    this.currentItemTapTimes = []; // Reset for next item

                    // Check if sequence complete
                    if (this.currentSequenceIndex >= this.gameSequence.length) {
                        // Calculate rhythm bonus for the ENTIRE sequence timing
                        this.calculateSequenceRhythmBonus();
                        setTimeout(() => this.nextRound(), 500);
                    }
                }

                this.playerPressedLight = lightIndex;
            }

            // Handle input for call and response mode
            handleCallResponsePress(lightIndex) {
                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.add('active');

                // PLAY AUDIO FEEDBACK
                const note = light.dataset.note;
                const frequency = this.notes[note];

                // For call and response, we need to record the actual performance
                if (this.isPlayer1Turn) {
                    // Player 1 is making the call - record everything they do
                    this.recordCallResponseInput(lightIndex, note, true); // true = is Player 1
                } else {
                    // Player 2 is responding - record and compare
                    this.recordCallResponseInput(lightIndex, note, false); // false = is Player 2
                }

                // Play audio feedback (no specific rhythm expected in call/response)
                this.playUserFeedbackTone(frequency, { taps: 1 }); // Single tap feedback

                this.playerPressedLight = lightIndex;
            }

            // Record input for call and response mode
            recordCallResponseInput(lightIndex, note, isPlayer1) {
                const timestamp = Date.now();

                const inputData = {
                    lightIndex,
                    note,
                    timestamp,
                    isPlayer1
                };

                if (isPlayer1) {
                    // Player 1 is creating the call
                    if (this.player1Sequence.length === 0) {
                        // First input - start timing
                        this.callResponseStartTime = timestamp;
                    }
                    this.player1Sequence.push(inputData);

                    // Update the last input time for silence detection
                    this.lastPlayer1InputTime = timestamp;
                } else {
                    // Player 2 is responding
                    if (this.playerSequence.length === 0) {
                        // First response - start timing
                        this.responseStartTime = timestamp;
                    }
                    this.playerSequence.push(inputData);

                    // Check if Player 2 has matched the length of Player 1's sequence
                    if (this.playerSequence.length >= this.player1Sequence.length) {
                        clearTimeout(this.callResponseTimeout);
                        this.compareCallResponse();
                    }
                }
            }

            // End Player 1's call and switch to Player 2
            endPlayer1Call() {
                if (this.player1Sequence.length === 0) {
                    // Player 1 didn't play anything, restart their turn
                    this.showCallResponseInstruction("Player 1: Try again!", "You need to play at least one note to create a call.");
                    return;
                }

                // Clear the silence checking interval
                clearInterval(this.silenceCheckInterval);

                this.isPlayer1Turn = false;
                this.isPlayerTurn = true;
                this.playerSequence = [];
                this.updateDisplay();

                // Show instruction for Player 2, then start their input
                this.showCallResponseInstruction("Player 2: Your turn!", `Match the ${this.player1Sequence.length} note${this.player1Sequence.length > 1 ? 's' : ''} that Player 1 just played.`);
            }

            // Compare Player 2's response to Player 1's call
            compareCallResponse() {
                clearTimeout(this.callResponseTimeout);

                if (this.playerSequence.length === 0) {
                    // Player 2 didn't respond
                    this.callResponseFeedback("Player 2 didn't respond!", false);
                    return;
                }

                // Compare pitch accuracy (100% required)
                let pitchMatch = true;
                let rhythmAccuracy = 0;

                const minLength = Math.min(this.player1Sequence.length, this.playerSequence.length);

                // Check pitch accuracy
                for (let i = 0; i < minLength; i++) {
                    if (this.player1Sequence[i].note !== this.playerSequence[i].note) {
                        pitchMatch = false;
                        break;
                    }
                }

                // Check sequence length
                if (this.player1Sequence.length !== this.playerSequence.length) {
                    pitchMatch = false;
                }

                // Calculate rhythm accuracy (timing comparison)
                if (pitchMatch && this.player1Sequence.length > 1) {
                    const player1Intervals = [];
                    const player2Intervals = [];

                    // Calculate intervals between notes
                    for (let i = 1; i < this.player1Sequence.length; i++) {
                        player1Intervals.push(this.player1Sequence[i].timestamp - this.player1Sequence[i - 1].timestamp);
                    }
                    for (let i = 1; i < this.playerSequence.length; i++) {
                        player2Intervals.push(this.playerSequence[i].timestamp - this.playerSequence[i - 1].timestamp);
                    }

                    // Compare intervals with 75% tolerance
                    let matchingIntervals = 0;
                    for (let i = 0; i < player1Intervals.length; i++) {
                        const expected = player1Intervals[i];
                        const actual = player2Intervals[i];
                        const tolerance = expected * 0.25; // 25% tolerance (so 75% accuracy required)

                        if (Math.abs(actual - expected) <= tolerance) {
                            matchingIntervals++;
                        }
                    }

                    rhythmAccuracy = matchingIntervals / player1Intervals.length;
                } else if (pitchMatch && this.player1Sequence.length === 1) {
                    // Single note - rhythm doesn't matter
                    rhythmAccuracy = 1.0;
                }

                // Determine success
                const success = pitchMatch && rhythmAccuracy >= 0.75;

                // Calculate pitch accuracy stats
                let correctNotes = 0;
                for (let i = 0; i < minLength; i++) {
                    if (this.player1Sequence[i].note === this.playerSequence[i].note) {
                        correctNotes++;
                    }
                }
                const totalNotes = this.player1Sequence.length;
                const pitchPercentage = totalNotes > 0 ? Math.round((correctNotes / totalNotes) * 100) : 0;

                if (success) {
                    // Calculate multipliers for call & response
                    const rhythmMultiplier = this.enabledRhythms.length; // 1-4x based on number of rhythms
                    const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                    const noteMultiplier = Math.max(1, availableNotes.length - 2); // 3 notes = x1, 4 notes = x2, etc.
                    const totalMultiplier = rhythmMultiplier * noteMultiplier;

                    const basePoints = 100;
                    const multipliedPoints = basePoints * totalMultiplier;
                    this.totalScore += multipliedPoints;

                    this.callResponseFeedback(`Excellent! Notes: ${correctNotes}/${totalNotes}, Rhythm: ${Math.round(rhythmAccuracy * 100)}% (+${multipliedPoints} pts)`, true);
                } else if (!pitchMatch) {
                    // Notes are wrong - focus on note feedback
                    this.callResponseFeedback(`Nearly there! Notes: ${correctNotes}/${totalNotes} (${pitchPercentage}%) - Almost!`, false);
                } else {
                    // Notes are correct but rhythm is wrong - focus on rhythm feedback
                    this.callResponseFeedback(`Good notes! Rhythm: ${Math.round(rhythmAccuracy * 100)}% - Almost!`, false);
                }
            }

            // Show feedback for call and response
            callResponseFeedback(message, success) {
                // Create feedback overlay similar to level celebration
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const feedbackText = document.createElement('div');
                feedbackText.textContent = message;
                feedbackText.style.cssText = `
                    color: ${success ? '#4CAF50' : '#F44336'};
                    font-size: 2rem;
                    font-weight: bold;
                    text-align: center;
                    background: white;
                    padding: 30px;
                    border-radius: 20px;
                    border: 3px solid ${success ? '#4CAF50' : '#F44336'};
                `;

                overlay.appendChild(feedbackText);
                document.body.appendChild(overlay);

                // Remove after 3 seconds and start new round
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    this.startNewCallResponseRound();
                }, 3000);
            }

            // Start a new round in call and response mode
            startNewCallResponseRound() {
                this.currentRound++;
                this.callResponseRound++; // Increment call & response round
                this.isPlayer1Turn = true;
                this.player1Sequence = [];
                this.playerSequence = [];
                this.updateDisplay();
                this.startCallResponseTurn();
            }

            // Handle light release - No beeping
            onLightRelease(lightIndex, event) {
                if (!this.isPlayerTurn || this.playerPressedLight !== lightIndex) return;

                const light = document.getElementById(`light-${lightIndex}`);
                light.classList.remove('active');

                this.playerPressedLight = null;
            }

            // Calculate rhythm bonus for the ENTIRE sequence timing - called only after complete sequence
            calculateSequenceRhythmBonus() {
                if (this.playerSequence.length === 0) {
                    return;
                }

                const beatDuration = 60000 / this.bpm; // Duration of one beat in ms
                let rhythmAccuracy = 0; // Initialize rhythm accuracy variable
                console.log(`=== COMPLETE SEQUENCE RHYTHM ANALYSIS ===`);
                console.log(`BPM: ${this.bpm}, Beat duration: ${beatDuration}ms`);
                console.log(`Sequence length: ${this.gameSequence.length} items`);

                // Collect ALL tap times from the entire sequence
                let allPlayerTaps = [];
                let sequenceItemTypes = [];

                for (let i = 0; i < this.playerSequence.length; i++) {
                    const playerItem = this.playerSequence[i];
                    const gameItem = this.gameSequence[i];

                    if (playerItem.tapTimes && playerItem.tapTimes.length > 0) {
                        // Add all taps from this item
                        for (let tapTime of playerItem.tapTimes) {
                            allPlayerTaps.push({
                                time: tapTime,
                                itemIndex: i,
                                tapWithinItem: allPlayerTaps.filter(t => t.itemIndex === i).length,
                                expectedTaps: gameItem.rhythmData.taps,
                                rhythm: gameItem.rhythm
                            });
                        }
                        sequenceItemTypes.push({
                            rhythm: gameItem.rhythm,
                            taps: gameItem.rhythmData.taps
                        });
                    }
                }

                console.log(`Total taps collected: ${allPlayerTaps.length}`);
                console.log(`Player tap times: [${allPlayerTaps.map((t, i) => i === 0 ? '0ms' : (t.time - allPlayerTaps[0].time).toFixed(0) + 'ms').join(', ')}]`);

                // Calculate expected tap count
                const expectedTapCount = this.gameSequence.reduce((total, item) => total + item.rhythmData.taps, 0);
                console.log(`Expected total taps: ${expectedTapCount}, Got: ${allPlayerTaps.length}`);

                // STRICT VALIDATION: Wrong number of taps = 0% accuracy
                if (allPlayerTaps.length !== expectedTapCount) {
                    rhythmAccuracy = 0;
                    console.log(`‚ùå WRONG TAP COUNT: Expected ${expectedTapCount}, got ${allPlayerTaps.length} - 0% accuracy`);
                } else if (allPlayerTaps.length < 2) {
                    // Single tap sequences can't measure rhythm pattern
                    if (this.gameSequence.length === 1 && expectedTapCount === 1) {
                        // Single note sequence - give reasonable score for timing
                        rhythmAccuracy = 0.6; // 60% for single notes (can't measure rhythm)
                        console.log(`Single note sequence - 60% accuracy (no rhythm pattern to measure)`);
                    } else {
                        rhythmAccuracy = 0;
                        console.log(`‚ùå Single tap in multi-note sequence - 0% accuracy`);
                    }
                } else {
                    // Build expected timing pattern for the entire sequence
                    let expectedTapTimes = [];
                    let currentBeatStart = 0;

                    for (let i = 0; i < this.gameSequence.length; i++) {
                        const gameItem = this.gameSequence[i];
                        const tapsInThisBeat = gameItem.rhythmData.taps;

                        // Add expected tap times for this beat
                        for (let tap = 0; tap < tapsInThisBeat; tap++) {
                            const positionInBeat = tap / tapsInThisBeat; // 0, 0.25, 0.5, 0.75 for sixteenth notes
                            const expectedTime = currentBeatStart + (positionInBeat * beatDuration);
                            expectedTapTimes.push(expectedTime);
                        }

                        currentBeatStart += beatDuration; // Move to next beat
                    }

                    console.log(`Expected tap times: [${expectedTapTimes.map(t => t.toFixed(0) + 'ms').join(', ')}]`);

                    // Calculate actual timing relative to first tap
                    let actualTapTimes = allPlayerTaps.map(tap => tap.time - allPlayerTaps[0].time);

                    console.log(`\n=== STRICT EDUCATIONAL RHYTHM VALIDATION ===`);

                    // STEP 1: Anti-cheating validation - Check for obviously wrong patterns
                    const expectedTotalTime = expectedTapTimes[expectedTapTimes.length - 1];
                    const actualTotalTime = actualTapTimes[actualTapTimes.length - 1];
                    const overallTempoError = Math.abs(actualTotalTime - expectedTotalTime) / expectedTotalTime;

                    console.log(`Expected total time: ${expectedTotalTime.toFixed(0)}ms`);
                    console.log(`Actual total time: ${actualTotalTime.toFixed(0)}ms`);
                    console.log(`Overall tempo error: ${(overallTempoError * 100).toFixed(1)}%`);

                    // ANTI-CHEAT: Detect common gaming attempts
                    let cheatDetected = false;

                    // Cheat detection 1: Playing way too fast (double speed or faster)
                    if (actualTotalTime > 0 && actualTotalTime < expectedTotalTime * 0.4) {
                        cheatDetected = true;
                        console.log(`üö´ CHEAT DETECTED: Playing too fast (${(actualTotalTime / expectedTotalTime * 100).toFixed(0)}% of expected speed)`);
                    }

                    // Cheat detection 2: Playing way too slow (half speed or slower)  
                    if (actualTotalTime > expectedTotalTime * 2.5) {
                        cheatDetected = true;
                        console.log(`üö´ CHEAT DETECTED: Playing too slow (${(actualTotalTime / expectedTotalTime * 100).toFixed(0)}% of expected speed)`);
                    }

                    // Cheat detection 3: Suspiciously uniform timing (like rapid clicking)
                    if (actualTapTimes.length > 2) {
                        let actualGaps = [];
                        for (let i = 1; i < actualTapTimes.length; i++) {
                            actualGaps.push(actualTapTimes[i] - actualTapTimes[i - 1]);
                        }
                        const minGap = Math.min(...actualGaps);
                        const maxGap = Math.max(...actualGaps);
                        if (maxGap > 0 && minGap < 50 && maxGap / minGap > 10) {
                            cheatDetected = true;
                            console.log(`üö´ CHEAT DETECTED: Suspicious timing pattern (gaps from ${minGap}ms to ${maxGap}ms)`);
                        }
                    }

                    if (cheatDetected) {
                        rhythmAccuracy = 0;
                        console.log(`‚ùå CHEAT PREVENTION: 0% accuracy due to gaming attempt`);
                    } else if (overallTempoError > 0.20) {
                        // STRICT: If overall tempo is off by more than 20%, fail immediately
                        rhythmAccuracy = 0;
                        console.log(`‚ùå TEMPO FAIL: ${(overallTempoError * 100).toFixed(1)}% error > 20% threshold - 0% accuracy`);
                    } else {
                        // STEP 2: Check individual gap accuracy (rhythm pattern)
                        let actualGaps = [];
                        let expectedGaps = [];

                        for (let i = 1; i < actualTapTimes.length; i++) {
                            actualGaps.push(actualTapTimes[i] - actualTapTimes[i - 1]);
                            expectedGaps.push(expectedTapTimes[i] - expectedTapTimes[i - 1]);
                        }

                        console.log(`CPU gaps: [${expectedGaps.map(g => g.toFixed(0) + 'ms').join(', ')}]`);
                        console.log(`Player gaps: [${actualGaps.map(g => g.toFixed(0) + 'ms').join(', ')}]`);

                        // ULTRA-STRICT: Each gap must be within 10% of expected
                        let failedGaps = 0;
                        let gapAccuracySum = 0;
                        const gapTolerance = 0.10; // 10% tolerance per gap (STRICT)

                        for (let i = 0; i < expectedGaps.length; i++) {
                            const expectedGap = expectedGaps[i];
                            const actualGap = actualGaps[i];
                            const gapError = Math.abs(actualGap - expectedGap) / expectedGap;

                            console.log(`Gap ${i + 1}: Expected=${expectedGap.toFixed(0)}ms, Actual=${actualGap.toFixed(0)}ms, Error=${(gapError * 100).toFixed(1)}%`);

                            if (gapError > gapTolerance) {
                                failedGaps++;
                                console.log(`  ‚ùå GAP FAIL: ${(gapError * 100).toFixed(1)}% > ${(gapTolerance * 100)}% tolerance`);
                                gapAccuracySum += 0; // 0% for failed gaps
                            } else {
                                // Linear scoring within tolerance: 0% error = 100%, 10% error = 0%
                                const gapScore = Math.max(0, 1 - (gapError / gapTolerance));
                                gapAccuracySum += gapScore;
                                console.log(`  ‚úì Gap OK: ${(gapScore * 100).toFixed(1)}% accuracy`);
                            }
                        }

                        // Calculate rhythm accuracy as average of gap accuracies
                        rhythmAccuracy = gapAccuracySum / expectedGaps.length;

                        console.log(`\nGap Analysis: ${failedGaps}/${expectedGaps.length} gaps failed`);
                        console.log(`Average gap accuracy: ${(rhythmAccuracy * 100).toFixed(1)}%`);

                        // STEP 3: Additional penalties for educational purposes

                        // Penalty for inconsistent rhythm patterns
                        if (expectedGaps.length > 1) {
                            // Check if gaps should be equal (like quarter notes)
                            const expectedGapConsistency = this.calculateGapConsistency(expectedGaps);
                            const actualGapConsistency = this.calculateGapConsistency(actualGaps);

                            if (expectedGapConsistency > 0.9) { // CPU played consistent rhythm
                                if (actualGapConsistency < 0.7) { // Player was inconsistent
                                    const consistencyPenalty = 0.5; // 50% penalty for inconsistency
                                    rhythmAccuracy *= consistencyPenalty;
                                    console.log(`‚ùå CONSISTENCY PENALTY: Player rhythm inconsistent (${(actualGapConsistency * 100).toFixed(1)}% vs expected ${(expectedGapConsistency * 100).toFixed(1)}%)`);
                                    console.log(`Applied 50% consistency penalty. New accuracy: ${(rhythmAccuracy * 100).toFixed(1)}%`);
                                }
                            }
                        }

                        // Penalty for rushing or dragging
                        if (overallTempoError > 0.10) { // More than 10% tempo error
                            const tempoPenalty = Math.max(0.3, 1 - (overallTempoError / 0.15)); // Penalty scales with error
                            rhythmAccuracy *= tempoPenalty;
                            console.log(`‚ùå TEMPO PENALTY: ${(overallTempoError * 100).toFixed(1)}% tempo error`);
                            console.log(`Applied ${((1 - tempoPenalty) * 100).toFixed(1)}% tempo penalty. New accuracy: ${(rhythmAccuracy * 100).toFixed(1)}%`);
                        }
                    }
                }

                // Final validation and reporting
                console.log(`\nüéØ FINAL EDUCATIONAL RHYTHM SCORE: ${(rhythmAccuracy * 100).toFixed(1)}%`);

                if (rhythmAccuracy < 0.1) {
                    console.log(`üìö Educational feedback: Rhythm needs significant improvement`);
                } else if (rhythmAccuracy < 0.5) {
                    console.log(`üìö Educational feedback: Rhythm partially correct but needs work`);
                } else if (rhythmAccuracy < 0.8) {
                    console.log(`üìö Educational feedback: Good rhythm with minor timing issues`);
                } else {
                    console.log(`üìö Educational feedback: Excellent rhythm accuracy!`);
                }

                // Store rhythm accuracy for stats
                this.rhythmAccuracy = rhythmAccuracy;

                // Award rhythm bonus based on STRICT accuracy - Educational standards
                let rhythmBonus = 0;

                // STRICT EDUCATIONAL BONUS SYSTEM:
                // Only reward genuinely good rhythm performance
                if (rhythmAccuracy >= 0.9) {
                    // Excellent rhythm (90%+) - Full bonus 
                    const remainingLevelBonus = Math.max(0, 250 - this.currentLevelRhythmBonus);
                    rhythmBonus = Math.min(250, remainingLevelBonus);
                    console.log(`üèÜ EXCELLENT RHYTHM: ${(rhythmAccuracy * 100).toFixed(1)}% - Full bonus ${rhythmBonus}`);
                    this.perfectTimingCount++;
                } else if (rhythmAccuracy >= 0.8) {
                    // Very good rhythm (80-89%) - Large bonus
                    const remainingLevelBonus = Math.max(0, 250 - this.currentLevelRhythmBonus);
                    rhythmBonus = Math.min(200, remainingLevelBonus);
                    console.log(`ü•à VERY GOOD RHYTHM: ${(rhythmAccuracy * 100).toFixed(1)}% - Large bonus ${rhythmBonus}`);
                } else if (rhythmAccuracy >= 0.7) {
                    // Good rhythm (70-79%) - Medium bonus
                    const remainingLevelBonus = Math.max(0, 250 - this.currentLevelRhythmBonus);
                    rhythmBonus = Math.min(100, remainingLevelBonus);
                    console.log(`ü•â GOOD RHYTHM: ${(rhythmAccuracy * 100).toFixed(1)}% - Medium bonus ${rhythmBonus}`);
                } else if (rhythmAccuracy >= 0.6) {
                    // Fair rhythm (60-69%) - Small bonus
                    const remainingLevelBonus = Math.max(0, 250 - this.currentLevelRhythmBonus);
                    rhythmBonus = Math.min(50, remainingLevelBonus);
                    console.log(`üìà FAIR RHYTHM: ${(rhythmAccuracy * 100).toFixed(1)}% - Small bonus ${rhythmBonus}`);
                } else {
                    // Poor rhythm (<60%) - No bonus (EDUCATIONAL: must earn the points)
                    rhythmBonus = 0;
                    console.log(`‚ùå POOR RHYTHM: ${(rhythmAccuracy * 100).toFixed(1)}% - No bonus awarded`);
                    console.log(`üìö Educational note: Practice the rhythm more carefully to earn bonus points`);
                }

                console.log(`Current level bonus total: ${this.currentLevelRhythmBonus}/250`);
                console.log(`Remaining level bonus available: ${Math.max(0, 250 - this.currentLevelRhythmBonus)}`);
                console.log(`Final bonus awarded: ${rhythmBonus}`);

                // Store bonus but DON'T add to total score yet - only track for level
                if (rhythmBonus > 0) {
                    // DON'T add to levelScore here - will be added at level completion
                    this.currentLevelRhythmBonus += rhythmBonus; // Track rhythm bonus for this level
                    console.log(`Added ${rhythmBonus} to level bonus tracking. New level bonus total: ${this.currentLevelRhythmBonus}/250`);
                    // DON'T add to totalScore here - only at end of level
                } else {
                    console.log(`No bonus added to level tracking`);
                }                // Accumulate rhythm accuracy for session statistics
                this.sessionRhythmAccuracySum += rhythmAccuracy;
                this.totalTimingAttempts++;
            }

            // Helper function to calculate how consistent gaps are (for rhythm accuracy)
            calculateGapConsistency(gaps) {
                if (gaps.length < 2) return 1.0; // Single gap is perfectly consistent

                // Calculate average gap
                const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;

                // Calculate how much each gap deviates from the average
                let totalDeviation = 0;
                gaps.forEach(gap => {
                    const deviation = Math.abs(gap - avgGap) / avgGap;
                    totalDeviation += deviation;
                });

                // Average deviation as percentage
                const avgDeviation = totalDeviation / gaps.length;

                // Convert to consistency score (0 = totally inconsistent, 1 = perfectly consistent)
                const consistency = Math.max(0, 1 - avgDeviation);

                console.log(`Gap analysis: avg=${avgGap.toFixed(0)}ms, avgDeviation=${(avgDeviation * 100).toFixed(1)}%, consistency=${(consistency * 100).toFixed(1)}%`);

                return consistency;
            }            // Detect rhythm based on duration
            detectRhythm(beats) {
                const rhythmEntries = Object.entries(this.rhythms);
                let closestRhythm = 'quarter';
                let smallestDiff = Infinity;

                // Don't auto-detect triplets, they're handled separately
                rhythmEntries.forEach(([key, data]) => {
                    if (key === 'triplet') return;
                    const diff = Math.abs(beats - data.beats);
                    if (diff < smallestDiff) {
                        smallestDiff = diff;
                        closestRhythm = key;
                    }
                });

                return closestRhythm;
            }

            // Advance to next round - Level progression based on sequence length
            nextRound() {
                // Check if we should advance to next level (based on sequence length)
                const targetSequenceLength = this.levelRequirements[this.currentLevel];
                if (this.gameSequence.length >= targetSequenceLength && this.currentLevel < 20) {
                    // Check for perfect accuracy bonus BEFORE advancing level
                    // Must have: 1) not used Listen Again, 2) level 5+, and 3) good rhythm accuracy
                    const avgRhythmAccuracy = this.totalTimingAttempts > 0 ?
                        (this.sessionRhythmAccuracySum / this.totalTimingAttempts) : 0;
                    const perfectAccuracy = !this.listenAgainUsed &&
                        this.currentLevel >= 5 &&
                        avgRhythmAccuracy >= 0.8; // Require 80%+ rhythm accuracy

                    const newLevel = this.currentLevel + 1;
                    this.currentLevel = newLevel;
                    this.correctInRow = 0; // Reset counter for new level
                    this.bpm = Math.min(50 + (newLevel - 1) * 2, 85); // 2 BPM per level, max 85
                    this.lastNoteIndex = -1; // Reset note tracking for new level
                    this.listenAgainUsed = false; // Reset Listen Again for new level
                    this.bonusListenAgainAwarded = false; // Reset bonus tracking for new level

                    // Update light colors for the new level
                    this.updateLightColors();

                    // Update level display in UI
                    this.updateLevelDisplay();

                    // Award bonus Listen Again for next level if perfect accuracy achieved
                    if (perfectAccuracy && !this.bonusListenAgainAwarded) {
                        this.normalListenAgainCount = 2; // Award bonus Listen Again for next level
                        this.showBonusListenAgainMessage();
                    } else {
                        this.normalListenAgainCount = 1; // Reset to normal for new level
                    }

                    // Show level completion celebration
                    this.showLevelCelebration(newLevel);
                    return; // Exit early, celebration will continue the game
                } else {
                    // Same level, continue building sequence
                    this.currentRound++;
                    // Add ONE new item to the existing sequence (Simon Says behavior)
                    this.gameSequence.push(this.generateSequenceItem());
                }

                // Reset player sequence for the new round
                this.playerSequence = [];
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.isPlayerTurn = false;

                this.updateDisplay();

                // Reduced pause before playing the ENTIRE sequence again
                setTimeout(() => {
                    if (this.pitchTrainingMode) {
                        this.playSequenceWithPitchTraining();
                    } else {
                        this.playSequence();
                    }
                }, 800); // Reduced from 1500ms to 800ms
            }

            // Show bonus Listen Again message
            showBonusListenAgainMessage() {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #f093fb, #f5576c);
                    color: white;
                    padding: 25px 35px;
                    border-radius: 20px;
                    font-size: 1.3rem;
                    font-weight: bold;
                    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
                    z-index: 10001;
                    border: 3px solid white;
                    font-family: 'Comic Sans MS', sans-serif;
                    text-align: center;
                    animation: bonusPulse 0.6s ease-out;
                `;
                message.innerHTML = `üéâ BONUS LISTEN AGAIN! üéâ<br><span style="font-size: 1rem;">Perfect accuracy unlocked an extra listen!</span>`;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 3000);
            }

            // Lose a life - restart the same level
            loseLife() {
                // Immediately stop player input to prevent further interaction
                this.isPlayerTurn = false;
                this.gameState = 'playing'; // Set to playing to block input

                // Clear any active visual feedback
                document.querySelectorAll('.light.active').forEach(light => {
                    light.classList.remove('active');
                });

                // Reset current sequence tracking
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.currentItemTapTimes = [];
                this.playerSequence = [];
                this.playerPressedLight = null;

                this.lives--;
                this.updateDisplay();

                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Show "Try Again" modal and replay sequence
                    this.showTryAgainModal();
                }
            }

            // Game over
            gameOver() {
                this.gameState = 'stopped';
                this.isPlayerTurn = false;
                this.correctInRow = 0; // Reset on game over
                this.lives = 3; // Reset lives for next game
                // No metronome to stop

                // Record game statistics
                // Use the accumulated rhythm accuracy from all sequences played this game
                const totalRhythmAccuracy = this.totalTimingAttempts > 0 ?
                    (this.sessionRhythmAccuracySum / this.totalTimingAttempts) : 0; // Keep as decimal 0-1
                const pitchAccuracy = this.currentRound > 1 ? ((this.currentRound - 1) / this.currentRound) : 1;
                this.updatePlayerStats(this.totalScore, this.currentLevel, totalRhythmAccuracy, pitchAccuracy);

                this.updateDisplay();
                this.updateControls();

                this.showGameOverModal();
            }

            // Show "Get Ready!" modal for 3 seconds then start sequence
            showGetReadyModal(callback) {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(5px);
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                    border-radius: 20px;
                    padding: 40px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 300px;
                    width: 90%;
                `;

                // "Get Ready!" title
                const title = document.createElement('div');
                title.textContent = 'Get Ready!';
                title.style.cssText = `
                    font-size: 2.5rem;
                    font-weight: bold;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                    animation: pulse 1s ease-in-out infinite alternate;
                `;

                // Add pulse animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes pulse {
                        from { transform: scale(1); }
                        to { transform: scale(1.05); }
                    }
                `;
                document.head.appendChild(style);

                modal.appendChild(title);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Remove modal after 3 seconds and call the callback
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);
                    if (callback) callback();
                }, 3000);
            }

            showGameOverModal() {
                // Play fail sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const failAudio = new Audio('fail.mp3');
                    failAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                // Game Over title
                const title = document.createElement('div');
                if (this.callResponseMode) {
                    title.textContent = this.player2Name ? `${this.player2Name} - Game Over` : 'Player 2 - Game Over';
                } else {
                    title.textContent = `${this.playerName} - Game Over`;
                }
                title.style.cssText = `
                    font-size: 2.2rem;
                    font-weight: bold;
                    margin-bottom: 20px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                `;

                // Score breakdown
                const scoreBreakdown = document.createElement('div');
                scoreBreakdown.style.cssText = `
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 15px;
                    padding: 20px;
                    margin-bottom: 25px;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                `;

                // Add personalized message based on mode
                let personalMessage = '';
                if (this.callResponseMode) {
                    personalMessage = `
                        <div style="font-size: 1.1rem; margin-bottom: 15px; font-style: italic;">
                            üéµ ${this.player2Name || 'Player 2'} challenged ${this.playerName}'s patterns! üéµ
                        </div>
                    `;
                } else if (this.pitchTrainingMode) {
                    personalMessage = `
                        <div style="font-size: 1.1rem; margin-bottom: 15px; font-style: italic;">
                            üéØ ${this.playerName} completed Pitch Training! üéØ
                        </div>
                    `;
                } else {
                    personalMessage = `
                        <div style="font-size: 1.1rem; margin-bottom: 15px; font-style: italic;">
                            üéÆ ${this.playerName} conquered the rhythm challenge! üéÆ
                        </div>
                    `;
                }

                const finalRound = document.createElement('div');
                finalRound.textContent = `Final Round: ${this.currentRound}`;
                finalRound.style.cssText = `
                    font-size: 1.2rem;
                    margin-bottom: 8px;
                    font-weight: bold;
                `;

                const finalLevel = document.createElement('div');
                finalLevel.textContent = `Final Level: ${this.currentLevel}`;
                finalLevel.style.cssText = `
                    font-size: 1.2rem;
                    margin-bottom: 8px;
                    font-weight: bold;
                `;

                const finalScore = document.createElement('div');
                finalScore.textContent = `Total Score: ${this.totalScore.toLocaleString()}`;
                finalScore.style.cssText = `
                    font-size: 1.4rem;
                    font-weight: bold;
                    color: #ffeb3b;
                    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
                `;

                // Add personal message to scoreBreakdown
                scoreBreakdown.innerHTML = personalMessage;
                scoreBreakdown.appendChild(finalRound);
                scoreBreakdown.appendChild(finalLevel);
                scoreBreakdown.appendChild(finalScore);

                // Button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                    flex-wrap: wrap;
                `;

                // Start Again button (reset to level 1)
                const startAgainBtn = document.createElement('button');
                startAgainBtn.textContent = 'Start Again';
                startAgainBtn.style.cssText = `
                    background: linear-gradient(45deg, #28a745, #20c997);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                startAgainBtn.onmouseover = () => {
                    startAgainBtn.style.transform = 'translateY(-2px)';
                    startAgainBtn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                startAgainBtn.onmouseout = () => {
                    startAgainBtn.style.transform = 'translateY(0)';
                    startAgainBtn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };
                startAgainBtn.onclick = () => {
                    document.body.removeChild(overlay);

                    // Complete reset to level 1
                    this.currentLevel = 1;
                    this.currentRound = 1;
                    this.totalScore = 0; // Reset score
                    this.levelScore = 0;
                    this.lives = 3; // Reset lives
                    this.correctInRow = 0;

                    // Reset Listen Again system
                    this.normalListenAgainCount = 1;
                    this.bonusListenAgainAwarded = false;
                    this.listenAgainUsed = false;
                    this.pitchTrainingListenCount = 0;

                    // Reset sequence tracking
                    this.gameSequence = [];
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.currentItemTapTimes = [];
                    this.playerPressedLight = null;

                    // Reset timing and rhythm tracking
                    this.rhythmAccuracy = 0;
                    this.perfectTimingCount = 0;
                    this.totalTimingAttempts = 0;
                    this.sessionRhythmAccuracySum = 0;
                    this.currentLevelRhythmBonus = 0;

                    // Reset game state
                    this.gameState = 'stopped';
                    this.isPlayerTurn = false;

                    this.updateDisplay();
                    this.updateControls();
                    this.updateNoteDisplay();
                    this.updateLightColors(); // Reset colors to level 1 (blue)
                };

                // Continue button (same level, reset score)
                const continueBtn = document.createElement('button');
                continueBtn.textContent = 'Continue';
                continueBtn.style.cssText = `
                    background: linear-gradient(45deg, #007bff, #6f42c1);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                continueBtn.onmouseover = () => {
                    continueBtn.style.transform = 'translateY(-2px)';
                    continueBtn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                continueBtn.onmouseout = () => {
                    continueBtn.style.transform = 'translateY(0)';
                    continueBtn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };
                continueBtn.onclick = () => {
                    document.body.removeChild(overlay);

                    // Store the current level and round we failed on
                    const failedLevel = this.currentLevel;
                    const failedRound = this.currentRound;

                    // Reset game stats but keep the level/round we failed on
                    this.currentLevel = failedLevel;
                    this.currentRound = failedRound;
                    this.totalScore = 0; // Reset score
                    this.levelScore = 0;
                    this.lives = 3; // Reset lives
                    this.correctInRow = 0;

                    // Set BPM for the current level (not reset to level 1)
                    this.bpm = Math.min(50 + (failedLevel - 1) * 2, 85); // 2 BPM per level, max 85
                    this.lastNoteIndex = -1; // Reset note tracking

                    // Reset Listen Again system
                    this.normalListenAgainCount = 1; // Reset Listen Again count
                    this.bonusListenAgainAwarded = false;
                    this.listenAgainUsed = false;
                    this.pitchTrainingListenCount = 0;

                    // Build a NEW sequence for the current level/round (not from level 1)
                    this.gameSequence = [];
                    for (let i = 0; i < failedRound; i++) {
                        this.gameSequence.push(this.generateSequenceItem());
                    }

                    // Reset player tracking
                    this.playerSequence = [];
                    this.currentSequenceIndex = 0;
                    this.currentTapCount = 0;
                    this.currentItemTapTimes = [];
                    this.playerPressedLight = null;

                    // Reset timing and rhythm tracking
                    this.rhythmAccuracy = 0;
                    this.perfectTimingCount = 0;
                    this.totalTimingAttempts = 0;
                    this.sessionRhythmAccuracySum = 0;
                    this.currentLevelRhythmBonus = 0;

                    // Reset game state and prepare to start
                    this.gameState = 'stopped';
                    this.isPlayerTurn = false;

                    this.updateDisplay();
                    this.updateControls();
                    this.updateNoteDisplay(); // Update notes for current level
                    this.updateLightColors(); // Maintain current level colors

                    // Switch to in-game UI and start playing the sequence
                    this.switchToInGameUI();

                    // Show "Get Ready!" modal then start the sequence
                    setTimeout(() => {
                        this.showGetReadyModal(() => {
                            if (this.pitchTrainingMode) {
                                this.playSequenceWithPitchTraining();
                            } else {
                                this.playSequence();
                            }
                        });
                    }, 500); // Brief delay to let UI update
                };

                // Quit button
                const quitBtn = document.createElement('button');
                quitBtn.textContent = 'Quit';
                quitBtn.style.cssText = `
                    background: linear-gradient(45deg, #dc3545, #c82333);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                quitBtn.onmouseover = () => {
                    quitBtn.style.transform = 'translateY(-2px)';
                    quitBtn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
                };
                quitBtn.onmouseout = () => {
                    quitBtn.style.transform = 'translateY(0)';
                    quitBtn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                };
                quitBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    // Just close modal, leave game state as stopped
                };

                buttonContainer.appendChild(startAgainBtn);
                buttonContainer.appendChild(continueBtn);
                buttonContainer.appendChild(quitBtn);

                modal.appendChild(title);
                modal.appendChild(scoreBreakdown);
                modal.appendChild(buttonContainer);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
            }

            // Show options modal
            showOptionsModal() {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    padding: 20px 0;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                    overflow-y: auto;
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #ffeaa7, #fab1a0);
                    border-radius: 20px;
                    padding: 20px;
                    text-align: center;
                    color: #2d3436;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 500px;
                    width: 90%;
                    max-height: 90vh;
                    overflow-y: auto;
                    overflow-x: hidden;
                    scrollbar-width: thin;
                    scrollbar-color: #8b5cf6 #f1f5f9;
                `;

                // Add scrollbar styles for webkit browsers
                const scrollbarStyle = document.createElement('style');
                scrollbarStyle.textContent = `
                    .modal-with-scroll::-webkit-scrollbar {
                        width: 8px;
                    }
                    .modal-with-scroll::-webkit-scrollbar-track {
                        background: #f1f5f9;
                        border-radius: 4px;
                    }
                    .modal-with-scroll::-webkit-scrollbar-thumb {
                        background: #8b5cf6;
                        border-radius: 4px;
                    }
                    .modal-with-scroll::-webkit-scrollbar-thumb:hover {
                        background: #7c3aed;
                    }
                `;
                document.head.appendChild(scrollbarStyle);
                modal.classList.add('modal-with-scroll');

                // Title
                const title = document.createElement('div');
                title.textContent = '‚öôÔ∏è Game Options';
                title.style.cssText = `
                    font-size: 2rem;
                    font-weight: bold;
                    margin-bottom: 20px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
                `;

                // Copy the hidden rhythm controls
                const rhythmSection = document.querySelector('.rhythm-controls').cloneNode(true);
                rhythmSection.style.display = 'block';
                rhythmSection.style.margin = '20px 0';
                rhythmSection.style.background = 'rgba(255, 255, 255, 0.7)';

                // Create sound FX section (extracted from scale controls)
                const soundFxSection = document.createElement('div');
                soundFxSection.style.cssText = `
                    display: block;
                    margin: 20px 0;
                    background: rgba(255, 255, 255, 0.7);
                    border-radius: 10px;
                    padding: 15px;
                `;
                soundFxSection.innerHTML = `
                    <h4 style="margin-bottom: 15px; color: #2d3436;">üîä Audio Options:</h4>
                    <div style="display: flex; justify-content: center;">
                        <label style="display: flex; align-items: center; background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;">
                            <input type="checkbox" id="modalMuteCheeringSound" ${document.getElementById('muteCheeringSound').checked ? 'checked' : ''} style="margin-right: 8px;">
                            <span>üîä Sound FX</span>
                        </label>
                    </div>
                `;

                // Add game mode section
                const gameModeSection = document.createElement('div');
                gameModeSection.style.cssText = `
                    display: block;
                    margin: 20px 0;
                    background: rgba(255, 255, 255, 0.7);
                    border-radius: 10px;
                    padding: 15px;
                `;
                const progressiveChecked = document.querySelector('input[name="scaleType"][value="progressive"]').checked;
                const customChecked = document.querySelector('input[name="scaleType"][value="custom"]').checked;
                gameModeSection.innerHTML = `
                    <h4 style="margin-bottom: 15px; color: #2d3436;">üéÆ Game Modes:</h4>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;">
                            <input type="radio" name="gameMode" value="normal" ${this.gameMode === 'normal' && progressiveChecked ? 'checked' : ''} style="margin-right: 8px;">
                            <span>üòé Fun Levels</span>
                        </label>
                        <label style="display: flex; align-items: center; background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;">
                            <input type="radio" name="gameMode" value="custom" ${this.gameMode === 'normal' && customChecked ? 'checked' : ''} style="margin-right: 8px;">
                            <span>üé® My Own Notes</span>
                        </label>
                        <label style="display: flex; align-items: center; background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;">
                            <input type="radio" name="gameMode" value="pitch-training" ${this.gameMode === 'pitch-training' ? 'checked' : ''} style="margin-right: 8px;">
                            <span>üéØ Pitch Training</span>
                        </label>
                        <label style="display: flex; align-items: center; background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;">
                            <input type="radio" name="gameMode" value="call-response" ${this.gameMode === 'call-response' ? 'checked' : ''} style="margin-right: 8px;">
                            <span>üë• 2 Player</span>
                        </label>
                    </div>
                `;

                // Add event listeners for immediate modal exit when selecting My Own Notes
                const modalGameModeRadios = gameModeSection.querySelectorAll('input[name="gameMode"]');
                modalGameModeRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.value === 'custom' && radio.checked) {
                            // Immediately close modal and enable custom note selection
                            this.syncOptionsFromModal(modal);
                            document.body.removeChild(overlay);
                            this.updateOptionsIndicator();
                        }
                    });
                });

                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úÖ Save & Close';
                closeBtn.style.cssText = `
                    background: linear-gradient(45deg, #00b894, #55a3ff);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 25px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s;
                    margin-top: 20px;
                `;

                closeBtn.onclick = () => {
                    // Copy values back to original inputs
                    this.syncOptionsFromModal(modal);
                    document.body.removeChild(overlay);
                    this.updateOptionsIndicator();
                };

                // New User button
                const newUserBtn = document.createElement('button');
                newUserBtn.textContent = 'üë§ New User';
                newUserBtn.style.cssText = `
                    background: linear-gradient(45deg, #fd79a8, #e84393);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s;
                    margin-top: 20px;
                    margin-right: 10px;
                `;

                newUserBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    this.startNewUser();
                };

                // Button container for better layout
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                    flex-wrap: wrap;
                    margin-top: 20px;
                `;

                buttonContainer.appendChild(newUserBtn);
                buttonContainer.appendChild(closeBtn);

                modal.appendChild(title);
                modal.appendChild(rhythmSection);
                modal.appendChild(soundFxSection);
                modal.appendChild(gameModeSection);
                modal.appendChild(buttonContainer);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Sync current values to modal
                this.syncOptionsToModal(modal);
            }

            // Show help modal
            showHelpModal() {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    padding: 20px 0;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                    overflow-y: auto;
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #a8e6cf, #88d8c0);
                    border-radius: 20px;
                    padding: 20px;
                    text-align: left;
                    color: #2d3436;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 600px;
                    width: 90%;
                    max-height: 90vh;
                    overflow-y: auto;
                    overflow-x: hidden;
                    scrollbar-width: thin;
                    scrollbar-color: #10b981 #f1f5f9;
                `;
                modal.classList.add('modal-with-scroll');

                modal.innerHTML = `
                    <h2 style="text-align: center; margin-bottom: 20px; color: #2d3436;">üéµ How to Play Copy-Cat! üéµ</h2>
                    
                    <div style="background: rgba(255,255,255,0.8); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <h3>üéØ Goal</h3>
                        <p>Listen to the musical patterns and copy them back perfectly! Match both the <strong>notes</strong> and the <strong>rhythm</strong>.</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.8); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <h3>üéÆ How to Play</h3>
                        <p>1. Press <strong>Start Game</strong></p>
                        <p>2. Listen carefully to the musical pattern</p>
                        <p>3. Click the colored lights to copy the pattern</p>
                        <p>4. Match the timing too - not just the notes!</p>
                        <p>5. Get it right to advance to longer patterns</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.8); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <h3>üéµ Rhythm Guide</h3>
                        <p><strong>‚ô© Quarter Notes (üü£ Plum):</strong> One tap per note</p>
                        <p><strong>‚ô´ Eighth Notes (üçé Apple):</strong> Two quick taps</p>
                        <p><strong>¬≥ Triplets (üçç Pineapple):</strong> Three taps in a beat</p>
                        <p><strong>‚ô¨ Sixteenth Notes (üçâ Watermelon):</strong> Four super-fast taps</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.8); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <h3>üéØ Special Modes</h3>
                        <p><strong>üéØ Pitch Training:</strong> Only the first note lights up - train your ear!</p>
                        <p><strong>üë• Call & Response:</strong> Two players take turns creating and copying patterns</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.8); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <h3>üí° Tips</h3>
                        <p>‚Ä¢ Use <strong>Listen Again</strong> if you need to hear it once more</p>
                        <p>‚Ä¢ Watch the rhythm colors to know what pattern to play</p>
                        <p>‚Ä¢ Perfect timing gives bonus points!</p>
                        <p>‚Ä¢ You have 3 lives - use them wisely!</p>
                    </div>

                    <div style="text-align: center; font-size: 0.9rem; color: #636e72; margin-top: 20px;">
                        <em>Written by James Mulvale 2025</em>
                    </div>

                    <button id="helpCloseBtn" style="
                        background: linear-gradient(45deg, #fd79a8, #e84393);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 25px;
                        font-size: 1.1rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s;
                        margin: 20px auto 0;
                        display: block;
                    ">‚ú® Got it! Let's Play! ‚ú®</button>
                `;

                modal.querySelector('#helpCloseBtn').onclick = () => {
                    document.body.removeChild(overlay);
                };

                overlay.appendChild(modal);
                document.body.appendChild(overlay);
            }

            // Sync options from modal back to original inputs
            syncOptionsFromModal(modal) {
                // Rhythm options
                const modalRhythms = modal.querySelectorAll('.rhythm-controls input[type="checkbox"]');
                modalRhythms.forEach(checkbox => {
                    const originalCheckbox = document.getElementById(checkbox.id);
                    if (originalCheckbox) {
                        originalCheckbox.checked = checkbox.checked;
                    }
                });

                // Sound FX option
                const modalSoundFx = modal.querySelector('#modalMuteCheeringSound');
                if (modalSoundFx) {
                    const originalSoundFx = document.getElementById('muteCheeringSound');
                    if (originalSoundFx) {
                        originalSoundFx.checked = modalSoundFx.checked;
                    }
                }

                // Note selection options
                const modalScaleRadios = modal.querySelectorAll('input[name="modalScaleType"]');
                modalScaleRadios.forEach(radio => {
                    if (radio.checked) {
                        const originalRadio = document.querySelector(`input[name="scaleType"][value="${radio.value}"]`);
                        if (originalRadio) {
                            originalRadio.checked = true;
                        }
                    }
                });

                // Update game mode from modal radio buttons
                const modalGameModeRadios = modal.querySelectorAll('input[name="gameMode"]');
                modalGameModeRadios.forEach(radio => {
                    if (radio.checked) {
                        if (radio.value === 'custom') {
                            // Custom notes mode - enable interactive note selection
                            this.gameMode = 'normal';
                            this.pitchTrainingMode = false;
                            this.callResponseMode = false;

                            // Set scale type to custom and enable selection mode
                            const customRadio = document.querySelector('input[name="scaleType"][value="custom"]');
                            if (customRadio) customRadio.checked = true;
                            const progressiveRadio = document.querySelector('input[name="scaleType"][value="progressive"]');
                            if (progressiveRadio) progressiveRadio.checked = false;

                            // Enable custom note selection mode for interactive keyboard
                            this.usingCustomScale = true;
                            this.customNoteSelectionMode = true;

                            // Hide custom container checkboxes, show interactive selection
                            const customContainer = document.getElementById('customScaleContainer');
                            customContainer.style.display = 'none';

                            // Update display and show save button
                            this.updateNoteDisplay();

                        } else {
                            // Other game modes
                            this.gameMode = radio.value;
                            switch (radio.value) {
                                case 'normal':
                                    this.pitchTrainingMode = false;
                                    this.callResponseMode = false;
                                    // Set scale type to progressive
                                    const progressiveRadio = document.querySelector('input[name="scaleType"][value="progressive"]');
                                    if (progressiveRadio) progressiveRadio.checked = true;
                                    const customRadio = document.querySelector('input[name="scaleType"][value="custom"]');
                                    if (customRadio) customRadio.checked = false;

                                    // Ensure we're not in custom selection mode
                                    this.usingCustomScale = false;
                                    this.customNoteSelectionMode = false;
                                    this.hideSaveCustomNotesButton();
                                    break;
                                case 'pitch-training':
                                    this.pitchTrainingMode = true;
                                    this.callResponseMode = false;
                                    break;
                                case 'call-response':
                                    this.pitchTrainingMode = false;
                                    this.callResponseMode = true;
                                    break;
                            }
                        }
                    }
                });

                // Reset pitch training count
                this.pitchTrainingListenCount = 0;

                // Trigger change events to update game state
                this.updateEnabledRhythms();

                // Only update scale state if we're not in the middle of setting up custom note selection
                if (!this.customNoteSelectionMode) {
                    const scaleRadios = document.querySelectorAll('input[name="scaleType"]');
                    scaleRadios.forEach(radio => {
                        if (radio.checked) {
                            this.usingCustomScale = radio.value === 'custom';
                            const customContainer = document.getElementById('customScaleContainer');

                            if (this.usingCustomScale && !this.customNoteSelectionMode) {
                                // Using custom scale (from Options) - don't enter selection mode
                                customContainer.style.display = 'none';
                                // Hide save button if it exists from previous cycling
                                this.hideSaveCustomNotesButton();
                            } else if (!this.usingCustomScale) {
                                // Exit custom note selection mode
                                this.customNoteSelectionMode = false;
                                customContainer.style.display = 'none';
                                // Hide save button if it exists
                                this.hideSaveCustomNotesButton();
                            }

                            this.updateNoteDisplay();
                        }
                    });
                }

                // Update display and controls to reflect game mode changes
                this.updateDisplay();
                this.updateControls();
            }

            // Sync current values to modal inputs
            syncOptionsToModal(modal) {
                // Rhythm options
                const originalRhythms = document.querySelectorAll('.rhythm-controls input[type="checkbox"]');
                originalRhythms.forEach(checkbox => {
                    const modalCheckbox = modal.querySelector(`#${checkbox.id}`);
                    if (modalCheckbox) {
                        modalCheckbox.checked = checkbox.checked;
                    }
                });

                // Sound FX option
                const originalSoundFx = document.getElementById('muteCheeringSound');
                const modalSoundFx = modal.querySelector('#modalMuteCheeringSound');
                if (originalSoundFx && modalSoundFx) {
                    modalSoundFx.checked = originalSoundFx.checked;
                }

                // Note selection options
                const originalScaleRadios = document.querySelectorAll('input[name="scaleType"]');
                originalScaleRadios.forEach(radio => {
                    const modalRadio = modal.querySelector(`input[name="modalScaleType"][value="${radio.value}"]`);
                    if (modalRadio) {
                        modalRadio.checked = radio.checked;
                    }
                });

                // Sync current game mode to modal
                const modalGameModeRadios = modal.querySelectorAll('input[name="gameMode"]');
                const currentScaleType = document.querySelector('input[name="scaleType"]:checked')?.value;
                modalGameModeRadios.forEach(radio => {
                    if (radio.value === 'custom') {
                        radio.checked = (this.gameMode === 'normal' && currentScaleType === 'custom');
                    } else if (radio.value === 'normal') {
                        radio.checked = (this.gameMode === 'normal' && currentScaleType === 'progressive');
                    } else {
                        radio.checked = (radio.value === this.gameMode);
                    }
                });
            }

            // Update the options indicator display
            // Cycle through rhythm combinations during gameplay
            cycleRhythms() {
                this.currentRhythmComboIndex = (this.currentRhythmComboIndex + 1) % this.rhythmCombinations.length;
                const newCombination = this.rhythmCombinations[this.currentRhythmComboIndex];

                // Update enabled rhythms
                this.enabledRhythms = [...newCombination];

                // Update checkboxes to match
                document.getElementById('rhythmQuarter').checked = newCombination.includes('quarter');
                document.getElementById('rhythmEighth').checked = newCombination.includes('eighth');
                document.getElementById('rhythmTriplet').checked = newCombination.includes('triplet');
                document.getElementById('rhythmSixteenth').checked = newCombination.includes('sixteenth');

                // Update options indicator
                this.updateOptionsIndicator();

                // Add pulse animation to rhythm tag
                setTimeout(() => {
                    const rhythmTag = document.querySelector('.rhythm-tag');
                    if (rhythmTag) {
                        rhythmTag.classList.add('pulse');
                        setTimeout(() => rhythmTag.classList.remove('pulse'), 600);
                    }
                }, 50);

                // Show feedback
                this.showRhythmChangeMessage(newCombination);
            }

            // Reset to quarter notes only (long press)
            resetToQuarterNotes() {
                this.currentRhythmComboIndex = 0; // First combination is just quarter
                this.enabledRhythms = ['quarter'];

                // Update checkboxes
                document.getElementById('rhythmQuarter').checked = true;
                document.getElementById('rhythmEighth').checked = false;
                document.getElementById('rhythmTriplet').checked = false;
                document.getElementById('rhythmSixteenth').checked = false;

                // Update options indicator
                this.updateOptionsIndicator();

                // Add pulse animation to rhythm tag
                setTimeout(() => {
                    const rhythmTag = document.querySelector('.rhythm-tag');
                    if (rhythmTag) {
                        rhythmTag.classList.add('pulse');
                        setTimeout(() => rhythmTag.classList.remove('pulse'), 600);
                    }
                }, 50);

                // Show feedback
                this.showRhythmResetMessage();
            }

            // Show rhythm selection menu
            showRhythmMenu() {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                `;

                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    color: white;
                    border: 3px solid white;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;

                // Title
                const title = document.createElement('div');
                title.textContent = 'üéµ Select Rhythms üéµ';
                title.style.cssText = `
                    font-size: 2rem;
                    font-weight: bold;
                    margin-bottom: 25px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
                    font-family: 'Comic Sans MS', sans-serif;
                `;

                // Rhythm options container
                const rhythmContainer = document.createElement('div');
                rhythmContainer.style.cssText = `
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 15px;
                    margin-bottom: 25px;
                `;

                // Define rhythm options
                const rhythmOptions = [
                    { id: 'rhythmQuarter', symbol: '‚ô©', name: 'Quarter', description: 'Steady beat' },
                    { id: 'rhythmEighth', symbol: '‚ô´', name: 'Eighth', description: 'Twice as fast' },
                    { id: 'rhythmTriplet', symbol: '¬≥', name: 'Triplet', description: 'Three per beat' },
                    { id: 'rhythmSixteenth', symbol: '‚ô¨', name: 'Sixteenth', description: 'Very fast' }
                ];

                // Create rhythm option buttons
                rhythmOptions.forEach(rhythm => {
                    const rhythmButton = document.createElement('div');
                    const isSelected = document.getElementById(rhythm.id).checked;

                    rhythmButton.style.cssText = `
                        background: ${isSelected ? 'linear-gradient(45deg, #00b894, #00cec9)' : 'rgba(255, 255, 255, 0.2)'};
                        border: 2px solid ${isSelected ? '#00b894' : 'rgba(255, 255, 255, 0.5)'};
                        border-radius: 15px;
                        padding: 20px 10px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        font-family: 'Comic Sans MS', sans-serif;
                        color: white;
                        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
                    `;

                    rhythmButton.innerHTML = `
                        <div style="font-size: 2.5rem; margin-bottom: 8px;">${rhythm.symbol}</div>
                        <div style="font-size: 1.1rem; font-weight: bold; margin-bottom: 5px;">${rhythm.name}</div>
                        <div style="font-size: 0.9rem; opacity: 0.9;">${rhythm.description}</div>
                    `;

                    // Add hover effects
                    rhythmButton.onmouseover = () => {
                        rhythmButton.style.transform = 'scale(1.05)';
                        rhythmButton.style.boxShadow = '0 8px 20px rgba(0, 0, 0, 0.3)';
                    };
                    rhythmButton.onmouseout = () => {
                        rhythmButton.style.transform = 'scale(1)';
                        rhythmButton.style.boxShadow = 'none';
                    };

                    // Toggle rhythm on click
                    rhythmButton.onclick = () => {
                        const checkbox = document.getElementById(rhythm.id);
                        checkbox.checked = !checkbox.checked;

                        // Update visual state
                        const newSelected = checkbox.checked;
                        rhythmButton.style.background = newSelected ? 'linear-gradient(45deg, #00b894, #00cec9)' : 'rgba(255, 255, 255, 0.2)';
                        rhythmButton.style.borderColor = newSelected ? '#00b894' : 'rgba(255, 255, 255, 0.5)';

                        // Update enabled rhythms and options indicator
                        this.updateEnabledRhythms();
                        this.updateOptionsIndicator();
                    };

                    rhythmContainer.appendChild(rhythmButton);
                });

                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úÖ Done';
                closeBtn.style.cssText = `
                    background: linear-gradient(45deg, #fd79a8, #e84393);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 25px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.2s;
                    font-family: 'Comic Sans MS', sans-serif;
                `;

                closeBtn.onmouseover = () => {
                    closeBtn.style.transform = 'scale(1.05)';
                };
                closeBtn.onmouseout = () => {
                    closeBtn.style.transform = 'scale(1)';
                };

                closeBtn.onclick = () => {
                    document.body.removeChild(overlay);
                };

                modal.appendChild(title);
                modal.appendChild(rhythmContainer);
                modal.appendChild(closeBtn);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                    }
                };
            }

            // Cycle through note options and game modes: Fun Levels ‚Üí My Own Notes ‚Üí Pitch Training ‚Üí 2 Player
            cycleNoteAndGameModes() {
                // Check current state and cycle through modes
                const isUsingCustomNotes = document.querySelector('input[name="scaleType"][value="custom"]')?.checked;

                if (!this.pitchTrainingMode && !this.callResponseMode && !isUsingCustomNotes) {
                    // Currently Fun Levels ‚Üí go to My Own Notes (if we have meaningful custom notes set)
                    const hasCustomNotes = this.customNotes && this.customNotes.length > 0;
                    const isDefaultCEG = hasCustomNotes && this.customNotes.length === 3 &&
                        this.customNotes.includes('C') && this.customNotes.includes('E') && this.customNotes.includes('G');

                    if (hasCustomNotes && !isDefaultCEG) {
                        // Switch to My Own Notes mode without changing the selected notes
                        this.gameMode = 'normal';
                        this.pitchTrainingMode = false;
                        this.callResponseMode = false;
                        this.usingCustomScale = true;

                        // Set scale radio to custom but don't enter selection mode
                        document.querySelector('input[name="scaleType"][value="progressive"]').checked = false;
                        document.querySelector('input[name="scaleType"][value="custom"]').checked = true;

                        // Hide save button since we're not in selection mode
                        this.hideSaveCustomNotesButton();
                        const customContainer = document.getElementById('customScaleContainer');
                        customContainer.style.display = 'none';

                        this.updateNoteDisplay();
                        this.showNoteAndGameModeChangeMessage('üé® My Own Notes');
                    } else {
                        // No custom notes saved or using default C E G, show message and skip to Pitch Training
                        this.showCustomNotesReminderMessage();

                        // Go directly to Pitch Training
                        this.pitchTrainingMode = true;
                        this.callResponseMode = false;
                        this.gameMode = 'pitch-training';

                        // Make sure we stay on progressive scale
                        document.querySelector('input[name="scaleType"][value="progressive"]').checked = true;
                        document.querySelector('input[name="scaleType"][value="custom"]').checked = false;
                        this.usingCustomScale = false;
                        this.customNoteSelectionMode = false;

                        this.hideSaveCustomNotesButton();
                        const customContainer = document.getElementById('customScaleContainer');
                        customContainer.style.display = 'none';
                        this.updateNoteDisplay();

                        // Show pitch training message after a brief delay
                        setTimeout(() => {
                            this.showNoteAndGameModeChangeMessage('üéØ Pitch Training');
                        }, 1500);
                    }
                } else if (!this.pitchTrainingMode && !this.callResponseMode && isUsingCustomNotes) {
                    // Currently My Own Notes ‚Üí go to Pitch Training
                    this.pitchTrainingMode = true;
                    this.callResponseMode = false;
                    this.gameMode = 'pitch-training';

                    // Switch back to progressive scale
                    document.querySelector('input[name="scaleType"][value="progressive"]').checked = true;
                    document.querySelector('input[name="scaleType"][value="custom"]').checked = false;
                    this.usingCustomScale = false;
                    this.customNoteSelectionMode = false;

                    this.hideSaveCustomNotesButton();
                    const customContainer = document.getElementById('customScaleContainer');
                    customContainer.style.display = 'none';
                    this.updateNoteDisplay();
                    this.showNoteAndGameModeChangeMessage('üéØ Pitch Training');
                } else if (this.pitchTrainingMode && !this.callResponseMode) {
                    // Pitch Training ‚Üí 2 Player
                    this.pitchTrainingMode = false;
                    this.callResponseMode = true;
                    this.gameMode = 'call-response';

                    // Just show the mode change message, don't prompt for name yet
                    this.showNoteAndGameModeChangeMessage('üë• 2 Player');
                } else if (this.callResponseMode) {
                    // 2 Player ‚Üí Fun Levels
                    this.pitchTrainingMode = false;
                    this.callResponseMode = false;
                    this.gameMode = 'normal';

                    // Make sure we're back to progressive scale (not custom)
                    document.querySelector('input[name="scaleType"][value="progressive"]').checked = true;
                    const customRadio = document.querySelector('input[name="scaleType"][value="custom"]');
                    if (customRadio) customRadio.checked = false;
                    this.usingCustomScale = false;
                    this.customNoteSelectionMode = false;

                    this.hideSaveCustomNotesButton();
                    const customContainer = document.getElementById('customScaleContainer');
                    customContainer.style.display = 'none';
                    this.updateNoteDisplay();
                    this.showNoteAndGameModeChangeMessage('üòé Fun Levels');
                }

                // Reset pitch training count and update everything
                this.pitchTrainingListenCount = 0;
                this.updateDisplay();
                this.updateControls();
                this.updateOptionsIndicator();
            }

            // Show note and game mode change feedback
            showNoteAndGameModeChangeMessage(mode) {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #00b894, #00cec9);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 15px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10001;
                    border: 2px solid white;
                    animation: slideInRight 0.3s ease-out;
                `;
                message.textContent = `Mode: ${mode}`;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 1500);
            }

            // Show custom notes reminder message
            showCustomNotesReminderMessage() {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #fd79a8, #fdcb6e);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 15px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10001;
                    border: 2px solid white;
                    animation: slideInRight 0.3s ease-out;
                    text-align: center;
                `;
                message.textContent = 'Change Custom Notes in Options';
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 1500);
            }

            // Cycle through note options during gameplay
            cycleNoteOptions() {
                if (this.gameState === 'stopped') {
                    this.currentNoteOptionIndex = (this.currentNoteOptionIndex + 1) % this.noteOptions.length;
                    const newOption = this.noteOptions[this.currentNoteOptionIndex];

                    if (newOption === 'progression') {
                        document.querySelector('input[name="scaleType"][value="progressive"]').checked = true;
                        this.usingCustomScale = false;
                        this.customNoteSelectionMode = false;
                    } else {
                        document.querySelector('input[name="scaleType"][value="custom"]').checked = true;
                        this.usingCustomScale = true;
                        this.customNoteSelectionMode = true;

                        // Hide checkboxes during custom mode
                        const customContainer = document.getElementById('customScaleContainer');
                        customContainer.style.display = 'none';
                    }

                    this.updateNoteDisplay();
                    this.updateOptionsIndicator();
                    this.showNoteOptionChangeMessage(newOption);
                }
            }

            // Toggle sound FX
            toggleSoundFX() {
                const soundFXCheckbox = document.getElementById('muteCheeringSound');
                soundFXCheckbox.checked = !soundFXCheckbox.checked;
                this.updateOptionsIndicator();
                this.showSoundFXToggleMessage(soundFXCheckbox.checked);
            }

            // Toggle My Own Notes in Pitch Training or 2 Player mode
            toggleMyOwnNotesInMode(useCustomNotes) {
                if (useCustomNotes) {
                    // Enable custom notes for this mode
                    document.querySelector('input[name="scaleType"][value="custom"]').checked = true;
                    document.querySelector('input[name="scaleType"][value="progressive"]').checked = false;
                    this.usingCustomScale = true;
                } else {
                    // Disable custom notes, use progressive scale
                    document.querySelector('input[name="scaleType"][value="progressive"]').checked = true;
                    document.querySelector('input[name="scaleType"][value="custom"]').checked = false;
                    this.usingCustomScale = false;
                }

                // Update display and controls
                this.updateNoteDisplay();
                this.updateOptionsIndicator();

                // Show feedback message
                const modeText = this.pitchTrainingMode ? 'Pitch Training' : '2 Player';
                const notesText = useCustomNotes ? 'My Own Notes' : 'Progressive Scale';
                this.showMyOwnNotesToggleMessage(modeText, notesText);
            }

            // Show rhythm change feedback
            showRhythmChangeMessage(combination) {
                const rhythmSymbols = {
                    quarter: '‚ô©',
                    eighth: '‚ô´',
                    triplet: '¬≥',
                    sixteenth: '‚ô¨'
                };
                const symbols = combination.map(r => rhythmSymbols[r]).join(' ');

                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white;
                    padding: 25px 40px;
                    border-radius: 20px;
                    font-size: 2rem;
                    font-weight: 900;
                    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
                    z-index: 10001;
                    border: 4px solid white;
                    animation: slideInRight 0.4s ease-out;
                    text-align: center;
                    font-family: 'Comic Sans MS', sans-serif;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                `;
                message.innerHTML = `üéµ Rhythms: <span style="font-size: 2.5rem; color: #000000;">${symbols}</span> üéµ`;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 2000);
            }

            // Show rhythm reset feedback
            showRhythmResetMessage() {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #f093fb, #f5576c);
                    color: white;
                    padding: 25px 40px;
                    border-radius: 20px;
                    font-size: 2rem;
                    font-weight: 900;
                    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
                    z-index: 10001;
                    border: 4px solid white;
                    animation: slideInRight 0.4s ease-out;
                    text-align: center;
                    font-family: 'Comic Sans MS', sans-serif;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                `;
                message.innerHTML = `üîÑ Reset to <span style="font-size: 2.5rem; color: #000000;">‚ô©</span> Quarter Notes üîÑ`;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 2000);
            }

            // Show note option change feedback
            showNoteOptionChangeMessage(option) {
                const optionText = option === 'progression' ? 'üòé Fun Levels' : 'üé® My Own Notes';

                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #00b894, #00cec9);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 15px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10001;
                    border: 2px solid white;
                    animation: slideInRight 0.3s ease-out;
                `;
                message.textContent = `Notes: ${optionText}`;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 1500);
            }

            // Show sound FX toggle feedback
            showSoundFXToggleMessage(enabled) {
                const statusText = enabled ? 'üîä Sound FX On' : 'üîá Sound FX Off';

                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #fd79a8, #e84393);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 15px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10001;
                    border: 2px solid white;
                    animation: slideInRight 0.3s ease-out;
                `;
                message.textContent = statusText;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 1500);
            }

            // Show My Own Notes toggle feedback
            showMyOwnNotesToggleMessage(mode, notesType) {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #a29bfe, #6c5ce7);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 15px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10001;
                    border: 2px solid white;
                    animation: slideInRight 0.3s ease-out;
                    text-align: center;
                `;
                message.textContent = `${mode}: ${notesType}`;
                document.body.appendChild(message);

                setTimeout(() => {
                    if (document.body.contains(message)) {
                        message.remove();
                    }
                }, 1500);
            }

            updateOptionsIndicator() {
                const indicator = document.getElementById('optionsIndicator');

                // Get enabled rhythms
                const enabledRhythms = [];
                if (document.getElementById('rhythmQuarter').checked) enabledRhythms.push('‚ô©');
                if (document.getElementById('rhythmEighth').checked) enabledRhythms.push('‚ô´');
                if (document.getElementById('rhythmTriplet').checked) enabledRhythms.push('¬≥');
                if (document.getElementById('rhythmSixteenth').checked) enabledRhythms.push('‚ô¨');

                // Get note mode and game mode combined
                let noteAndGameMode;
                if (this.pitchTrainingMode) {
                    noteAndGameMode = 'üéØ Pitch Training';
                } else if (this.callResponseMode) {
                    noteAndGameMode = 'üë• 2 Player';
                } else {
                    const funLevels = document.querySelector('input[name="scaleType"][value="progressive"]').checked;
                    noteAndGameMode = funLevels ? 'üòé Fun Levels' : 'üé® Own Notes';
                }

                // Get other options
                const soundFX = document.getElementById('muteCheeringSound').checked ? 'üîä Sound FX' : 'üîá Silent';

                // Get game mode
                const gameModeNames = {
                    'normal': 'üéÆ Normal',
                    'pitch-training': 'üéØ Pitch Training',
                    'call-response': 'üë• Call & Response'
                };
                const gameMode = gameModeNames[this.gameMode] || 'ÔøΩ Normal';

                // Update indicator
                indicator.innerHTML = `
                    <div class="option-tag rhythm-tag" data-option="rhythm">üéµ Rhythms: <span style="font-size: 1.3rem; color: #000000;">${enabledRhythms.join(' ')}</span></div>
                    <div class="option-tag note-tag" data-option="notes">Notes: ${noteAndGameMode}</div>
                    <div class="option-tag sound-tag" data-option="sound">${soundFX}</div>
                `;

                // Update the global My Own Notes checkbox
                const globalCheckbox = document.getElementById('useMyOwnNotesGlobal');
                const checkboxContainer = document.getElementById('myOwnNotesCheckboxContainer');
                if (globalCheckbox && checkboxContainer) {
                    // Set checkbox state
                    globalCheckbox.checked = this.usingCustomScale;

                    // Style based on current mode
                    if (!this.pitchTrainingMode && !this.callResponseMode && !this.usingCustomScale) {
                        // Fun Levels mode - grey out
                        checkboxContainer.style.opacity = '0.5';
                        checkboxContainer.style.cursor = 'not-allowed';
                        globalCheckbox.disabled = true;
                        checkboxContainer.style.background = 'rgba(200,200,200,0.7)';
                        checkboxContainer.style.borderColor = '#ccc';
                    } else {
                        // Other modes - active
                        checkboxContainer.style.opacity = '1';
                        checkboxContainer.style.cursor = 'pointer';
                        globalCheckbox.disabled = false;
                        checkboxContainer.style.background = 'rgba(255,255,255,0.9)';
                        checkboxContainer.style.borderColor = '#ddd';
                    }
                }

                // Add event listeners to option tags
                const rhythmTag = indicator.querySelector('.rhythm-tag');
                const noteTag = indicator.querySelector('.note-tag');
                const soundTag = indicator.querySelector('.sound-tag');

                // Rhythm tag - show rhythm selection menu any time
                if (rhythmTag) {
                    rhythmTag.addEventListener('click', () => {
                        this.showRhythmMenu();
                    });
                }

                // Note tag - cycle through three modes only when stopped (skips Own Notes - that's Options only)
                if (noteTag) {
                    noteTag.addEventListener('click', () => {
                        if (this.gameState === 'stopped') {
                            this.cycleNoteAndGameModes();
                        }
                        // Do nothing during gameplay
                    });
                }

                // Sound tag - always toggle
                if (soundTag) {
                    soundTag.addEventListener('click', () => {
                        this.toggleSoundFX();
                    });
                }
            }            // Start a new round with a fresh sequence for the current level
            startRound() {
                // Play start round sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const startRoundAudio = new Audio('startround.mp3');
                    startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Generate a new single-item sequence for the current level
                this.gameSequence = [this.generateSequenceItem()];
                this.playerSequence = [];
                this.currentSequenceIndex = 0;
                this.currentTapCount = 0;
                this.isPlayerTurn = false;

                this.updateDisplay();
                this.updateNoteDisplay();

                // Start playing the sequence
                setTimeout(() => {
                    // Play start round sound only if Sound FX is enabled
                    const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                    if (soundFxEnabled) {
                        const startRoundAudio = new Audio('startround.mp3');
                        startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                    }

                    // Show "Get Ready!" modal for 3 seconds, then start sequence
                    this.showGetReadyModal(() => {
                        if (this.pitchTrainingMode) {
                            this.playSequenceWithPitchTraining();
                        } else {
                            this.playSequence();
                        }
                    });
                }, 300);
            }

            // Update display elements
            updateDisplay() {
                document.getElementById('totalScore').textContent = this.totalScore.toLocaleString();

                // Update player name display
                const playerNameDisplay = document.getElementById('playerNameDisplay');
                const currentPlayerName = document.getElementById('currentPlayerName');
                if (this.playerName && this.gameStarted) {
                    if (this.callResponseMode) {
                        // Show both players in 2-player mode
                        const player2Display = this.player2Name || 'Player 2';
                        if (this.isPlayer1Turn) {
                            currentPlayerName.textContent = `${this.playerName} vs ${player2Display} - ${this.playerName}'s Turn`;
                        } else {
                            currentPlayerName.textContent = `${this.playerName} vs ${player2Display} - ${player2Display}'s Turn`;
                        }
                    } else {
                        currentPlayerName.textContent = this.playerName;
                    }
                    playerNameDisplay.style.display = 'block';
                } else {
                    playerNameDisplay.style.display = 'none';
                }

                if (this.callResponseMode) {
                    // Show current player with their role in Call & Response mode
                    if (this.isPlayer1Turn) {
                        document.getElementById('round').textContent = 'Player 1 - Call';
                    } else {
                        document.getElementById('round').textContent = 'Player 2 - Response';
                    }
                } else {
                    document.getElementById('round').textContent = this.currentRound;
                }

                if (this.pitchTrainingMode) {
                    // In Pitch Training mode, show lives normally (listens don't affect lives)
                    document.getElementById('lives').textContent = this.lives;
                } else {
                    document.getElementById('lives').textContent = this.lives;
                }

                // Keep the footer simple and fun for kids - no complex info!
            }

            // Level completion celebration with sound and visual effects
            showLevelCelebration(newLevel) {
                // Calculate score multipliers
                const rhythmMultiplier = this.enabledRhythms.length; // 1-4x based on number of rhythms

                const availableNotes = this.getAvailableNotesForLevel(this.currentLevel);
                const noteMultiplier = Math.max(1, availableNotes.length - 2); // 3 notes = x1, 4 notes = x2, etc.

                let pitchTrainingMultiplier = 1;
                if (this.pitchTrainingMode) {
                    pitchTrainingMultiplier = this.gameSequence.length; // x number of notes in sequence
                }

                // Calculate level scores
                const baseScore = 100; // 100 points for completing level
                const noteBonus = this.gameSequence.length * 50; // 50 points per note
                // rhythmBonus is already added to levelScore in calculateSequenceRhythmBonus

                // Base level score without rhythm bonus
                const baseLevelScore = baseScore + noteBonus;
                const rhythmBonus = this.currentLevelRhythmBonus; // Use the tracked rhythm bonus for this level

                // Apply all multipliers
                const totalMultiplier = rhythmMultiplier * noteMultiplier * pitchTrainingMultiplier;
                this.levelScore = (baseLevelScore + rhythmBonus) * totalMultiplier;
                this.totalScore += this.levelScore; // Add ENTIRE level score to total at end of level

                // Play kids cheering sound only if Sound FX is enabled
                const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                if (soundFxEnabled) {
                    const cheeringAudio = new Audio('kids-cheering-sound-effect.mp3');
                    cheeringAudio.play().catch(e => console.log('Audio play failed:', e));
                }

                // Create celebration overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    font-family: 'Comic Sans MS', 'Trebuchet MS', 'Lucida Grande', Arial, sans-serif;
                `;

                // Level title
                const celebrationText = document.createElement('div');
                celebrationText.textContent = `LEVEL ${newLevel}!`;
                celebrationText.style.cssText = `
                    font-size: 72px;
                    font-weight: 900;
                    color: white;
                    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
                    text-align: center;
                    animation: colorCycle 0.5s ease-in-out infinite alternate;
                    margin-bottom: 30px;
                `;

                // Score breakdown container
                const scoreContainer = document.createElement('div');
                scoreContainer.style.cssText = `
                    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
                    background-size: 400% 400%;
                    padding: 30px;
                    border-radius: 20px;
                    border: 4px solid white;
                    text-align: center;
                    animation: gradientShift 2s ease infinite;
                    min-width: 400px;
                `;

                // Individual score lines
                const baseScoreBeforeMultiplier = baseLevelScore + rhythmBonus;
                const scoreLines = [
                    { text: `Level Complete: +${baseScore}`, delay: 200 },
                    { text: `${this.gameSequence.length} Notes: +${noteBonus}`, delay: 600 },
                    rhythmBonus > 0 ? { text: `Rhythm Accuracy Bonus: +${rhythmBonus}`, delay: 1000 } : null,
                    { text: `Base Score: ${baseScoreBeforeMultiplier}`, delay: rhythmBonus > 0 ? 1200 : 1000 },
                    { text: `${this.enabledRhythms.length} Rhythms: x${rhythmMultiplier}`, delay: rhythmBonus > 0 ? 1400 : 1200, isMultiplier: true },
                    { text: `${availableNotes.length} Notes: x${noteMultiplier}`, delay: rhythmBonus > 0 ? 1600 : 1400, isMultiplier: true },
                    this.pitchTrainingMode ? { text: `Pitch Training: x${pitchTrainingMultiplier}`, delay: rhythmBonus > 0 ? 1800 : 1600, isMultiplier: true } : null,
                    { text: `Final Multiplier: x${totalMultiplier}`, delay: rhythmBonus > 0 ? 2000 : 1800, isMultiplier: true, isFinalMultiplier: true },
                    { text: `Level Total: ${this.levelScore}`, delay: rhythmBonus > 0 ? 2200 : 2000, isTotal: true },
                    { text: `Grand Total: ${this.totalScore.toLocaleString()}`, delay: rhythmBonus > 0 ? 2400 : 2200, isGrandTotal: true }
                ].filter(Boolean);

                scoreLines.forEach((scoreData, index) => {
                    const scoreLine = document.createElement('div');
                    scoreLine.style.cssText = `
                        font-size: ${scoreData.isGrandTotal ? '36px' : scoreData.isTotal ? '28px' : scoreData.isFinalMultiplier ? '26px' : scoreData.isMultiplier ? '22px' : '24px'};
                        font-weight: 900;
                        color: ${scoreData.isGrandTotal ? '#ff1744' : scoreData.isTotal ? '#00e676' : scoreData.isFinalMultiplier ? '#ffd700' : scoreData.isMultiplier ? '#ff9800' : 'white'};
                        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                        margin: 8px 0;
                        opacity: 0;
                        transform: translateY(20px);
                        animation: scoreReveal 0.5s ease forwards;
                        animation-delay: ${scoreData.delay}ms;
                        ${scoreData.isGrandTotal ? 'border-top: 3px solid white; padding-top: 15px; margin-top: 20px;' : ''}
                        ${scoreData.isFinalMultiplier ? 'border-top: 2px solid #ffd700; padding-top: 10px; margin-top: 15px;' : ''}
                    `;
                    scoreLine.textContent = scoreData.text;
                    scoreContainer.appendChild(scoreLine);
                });

                // Add rainbow color cycling animation and score reveal animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes colorCycle {
                        0% { color: #ff0000; }
                        16.67% { color: #ff8000; }
                        33.33% { color: #ffff00; }
                        50% { color: #00ff00; }
                        66.67% { color: #0080ff; }
                        83.33% { color: #8000ff; }
                        100% { color: #ff0080; }
                    }
                    @keyframes gradientShift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }
                    @keyframes scoreReveal {
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }
                    @keyframes bonusPulse {
                        0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                    @keyframes slideInRight {
                        0% { transform: translateX(100%); opacity: 0; }
                        100% { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);

                overlay.appendChild(celebrationText);
                overlay.appendChild(scoreContainer);
                document.body.appendChild(overlay);

                // Remove celebration after 3.5 seconds and continue game
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);

                    // Reset level scoring for next level
                    this.levelScore = 0;
                    this.perfectTimingCount = 0;
                    this.totalTimingAttempts = 0;
                    this.currentLevelRhythmBonus = 0; // Reset rhythm bonus for new level
                    this.listenAgainUsed = false; // Reset Listen Again for new level

                    // Continue with level progression
                    this.gameSequence = [this.generateSequenceItem()];
                    this.currentRound = 1; // Reset round counter for new level
                    this.updateNoteDisplay(); // Update available notes for new level
                    this.updateDisplay();

                    // Start the new level's sequence after a brief pause
                    setTimeout(() => {
                        // Play start round sound only if Sound FX is enabled
                        const soundFxEnabled = document.getElementById('muteCheeringSound').checked;
                        if (soundFxEnabled) {
                            const startRoundAudio = new Audio('startround.mp3');
                            startRoundAudio.play().catch(e => console.log('Audio play failed:', e));
                        }

                        // Show "Get Ready!" modal for 3 seconds, then start sequence
                        this.showGetReadyModal(() => {
                            if (this.pitchTrainingMode) {
                                this.playSequenceWithPitchTraining();
                            } else {
                                this.playSequence();
                            }
                        });
                    }, 500);
                }, 3500);
            }            // Show "Try Again" modal and replay sequence until correct
            showTryAgainModal() {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    font-family: 'Comic Sans MS', 'Trebuchet MS', 'Lucida Grande', Arial, sans-serif;
                `;

                const modalText = document.createElement('div');
                modalText.textContent = 'Try Again';
                modalText.style.cssText = `
                    font-size: 48px;
                    font-weight: 900;
                    color: #ff6b6b;
                    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
                    text-align: center;
                    background: white;
                    padding: 40px 60px;
                    border-radius: 20px;
                    border: 4px solid #ff6b6b;
                `;

                overlay.appendChild(modalText);
                document.body.appendChild(overlay);

                // Remove modal after 1.5 seconds and replay sequence
                setTimeout(() => {
                    document.body.removeChild(overlay);

                    // Reset player input position but keep same sequence
                    this.playerIndex = 0;
                    this.isPlayerTurn = false;
                    this.gameState = 'playing';

                    // Replay the same sequence after brief pause
                    setTimeout(() => {
                        if (this.pitchTrainingMode) {
                            this.playSequenceWithPitchTraining();
                        } else {
                            this.playSequence();
                        }
                    }, 500);
                }, 1500);
            }

            // Update control buttons
            updateControls() {
                const startBtn = document.getElementById('startBtn');
                const stopResetBtn = document.getElementById('stopResetBtn');
                const listenAgainBtn = document.getElementById('listenAgainBtn');
                const scaleRadios = document.querySelectorAll('input[name="scaleType"]');

                // Update Listen Again button text based on mode and available listens
                if (this.pitchTrainingMode) {
                    const remainingListens = 2 - this.pitchTrainingListenCount;
                    listenAgainBtn.innerHTML = `üëÇ Listen Again (${remainingListens})`;
                } else if (this.callResponseMode) {
                    listenAgainBtn.innerHTML = 'üëÇ Listen Again';
                } else {
                    // Normal mode - show remaining listens based on bonus system
                    const remainingListens = this.normalListenAgainCount - (this.listenAgainUsed ? 1 : 0);
                    listenAgainBtn.innerHTML = `üëÇ Listen Again (${remainingListens})`;
                }

                if (this.gameState === 'stopped') {
                    // Game stopped - start button enabled, listen again disabled
                    if (startBtn) {
                        startBtn.disabled = false;
                    }
                    if (listenAgainBtn) {
                        listenAgainBtn.disabled = true;
                    }

                    // Enable scale selection when game is stopped
                    scaleRadios.forEach(radio => radio.disabled = false);
                } else {
                    // Game playing - update button states
                    if (stopResetBtn) {
                        stopResetBtn.disabled = false;
                    }

                    // Listen Again button logic depends on game mode
                    if (this.callResponseMode) {
                        // No Listen Again in call & response mode
                        listenAgainBtn.disabled = true;
                    } else if (this.pitchTrainingMode) {
                        // In pitch training, allow 2 Listen Again uses
                        listenAgainBtn.disabled = !(this.gameState === 'listening' && this.isPlayerTurn && this.pitchTrainingListenCount < 2);
                    } else {
                        // Normal mode - check if any listens remain
                        const remainingListens = this.normalListenAgainCount - (this.listenAgainUsed ? 1 : 0);
                        listenAgainBtn.disabled = !(this.gameState === 'listening' && this.isPlayerTurn && remainingListens > 0);
                    }

                    // Disable scale selection during active game
                    scaleRadios.forEach(radio => radio.disabled = true);
                }
            }

            // Clear all timeouts
            clearAllTimeouts() {
                if (this.sequenceTimeout) {
                    clearTimeout(this.sequenceTimeout);
                    this.sequenceTimeout = null;
                }
                if (this.playerTimeout) {
                    clearTimeout(this.playerTimeout);
                    this.playerTimeout = null;
                }
            }

            // Clear all light effects
            clearAllLights() {
                document.querySelectorAll('.light').forEach(light => {
                    light.classList.remove('active', 'playing');
                });
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new MemoryRhythmGame();
        });
    </script>
</body>

</html>